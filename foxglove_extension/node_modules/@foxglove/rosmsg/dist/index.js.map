{"version":3,"file":"index.js","mappings":";;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,aAAa;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wBAAwB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD,iCAAiC;AACjC,iCAAiC;AACjC,iCAAiC;AACjC,iCAAiC;AACjC;AACA,CAAC;AACc;AACf;;;;;;;ACrMA;AACA,MAAM,IAA0C;AAChD,IAAI,iCAAO,EAAE,oCAAE,OAAO;AAAA;AAAA;AAAA,kGAAC;AACvB,IAAI,KAAK,EAIN;AACH,CAAC;AACD;;AAEA;AACA;AACA;;AAEA;;AAEA,yBAAyB;AACzB,yBAAyB;;AAEzB;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA,+CAA+C,oCAAoC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;;AAEA,oBAAoB,kBAAkB;AACtC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA,sBAAsB,cAAc;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qBAAqB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;;AAEA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA,sBAAsB,mBAAmB;AACzC;AACA;AACA;AACA,sBAAsB,qBAAqB;AAC3C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,sBAAsB;AACtB;AACA,sCAAsC;AACtC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,OAAO;AACP,kBAAkB;AAClB;AACA,gBAAgB;AAChB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,+CAA+C;AAC/C;AACA,IAAI,yBAAyB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,qCAAqC,cAAc;AACnD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA,+BAA+B;AAC/B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA,0BAA0B,YAAY;AACtC,6BAA6B,eAAe;AAC5C;AACA;;AAEA,CAAC;;;;;;;;ACvlBD;AACA;AACA;AACA,iBAAiB;;AAEjB,YAAY,mBAAO,CAAC,GAAK;AACzB;AACA,UAAU,+BAA+B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;AAGD;AACA,kCAAkC,YAAY,KAAK;AACnD;AACA;AACA;AACA;AACA,KAAK,iEAAiE;AACtE,KAAK,kEAAkE,cAAc;AACrF,KAAK,qIAAqI,mBAAmB;AAC7J,KAAK,iEAAiE;AACtE,KAAK,kEAAkE,cAAc;AACrF,KAAK,uIAAuI,mBAAmB;AAC/J,KAAK,iEAAiE;AACtE,KAAK,kEAAkE,cAAc;AACrF,KAAK,wIAAwI,mBAAmB;AAChK,KAAK,iEAAiE;AACtE,KAAK,kEAAkE,cAAc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AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,kBAAkB;AAC1D;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,sDAAsD;AACnG;AACA,yBAAyB;AACzB;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2CAA2C,KAAK;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,2DAA2D;AAC3G;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,+CAA+C,gBAAgB;AAC/D;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;;;;;;;;;;ACjjBD;;;GAGG;AAEH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","sources":["webpack://@foxglove/rosmsg/./node_modules/md5-typescript/dist/index.js","webpack://@foxglove/rosmsg/./node_modules/moo/moo.js","webpack://@foxglove/rosmsg/./src/ros1.ne","webpack://@foxglove/rosmsg/./src/ros2idl.ne","webpack://@foxglove/rosmsg/./node_modules/nearley/lib/nearley.js","webpack://@foxglove/rosmsg/./src/buildRos2Type.ts","webpack://@foxglove/rosmsg/./src/index.ts","webpack://@foxglove/rosmsg/./src/md5.ts","webpack://@foxglove/rosmsg/./src/parse.ts","webpack://@foxglove/rosmsg/./src/parseRos2idl.ts","webpack://@foxglove/rosmsg/./src/stringify.ts","webpack://@foxglove/rosmsg/webpack/bootstrap","webpack://@foxglove/rosmsg/webpack/runtime/define property getters","webpack://@foxglove/rosmsg/webpack/runtime/hasOwnProperty shorthand","webpack://@foxglove/rosmsg/webpack/runtime/make namespace object","webpack://@foxglove/rosmsg/webpack/before-startup","webpack://@foxglove/rosmsg/webpack/startup","webpack://@foxglove/rosmsg/webpack/after-startup"],"sourcesContent":["var Md5 = /** @class */ (function () {\n    function Md5() {\n    }\n    Md5.AddUnsigned = function (lX, lY) {\n        var lX4, lY4, lX8, lY8, lResult;\n        lX8 = (lX & 0x80000000);\n        lY8 = (lY & 0x80000000);\n        lX4 = (lX & 0x40000000);\n        lY4 = (lY & 0x40000000);\n        lResult = (lX & 0x3FFFFFFF) + (lY & 0x3FFFFFFF);\n        if (!!(lX4 & lY4)) {\n            return (lResult ^ 0x80000000 ^ lX8 ^ lY8);\n        }\n        if (!!(lX4 | lY4)) {\n            if (!!(lResult & 0x40000000)) {\n                return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);\n            }\n            else {\n                return (lResult ^ 0x40000000 ^ lX8 ^ lY8);\n            }\n        }\n        else {\n            return (lResult ^ lX8 ^ lY8);\n        }\n    };\n    Md5.FF = function (a, b, c, d, x, s, ac) {\n        a = this.AddUnsigned(a, this.AddUnsigned(this.AddUnsigned(this.F(b, c, d), x), ac));\n        return this.AddUnsigned(this.RotateLeft(a, s), b);\n    };\n    Md5.GG = function (a, b, c, d, x, s, ac) {\n        a = this.AddUnsigned(a, this.AddUnsigned(this.AddUnsigned(this.G(b, c, d), x), ac));\n        return this.AddUnsigned(this.RotateLeft(a, s), b);\n    };\n    Md5.HH = function (a, b, c, d, x, s, ac) {\n        a = this.AddUnsigned(a, this.AddUnsigned(this.AddUnsigned(this.H(b, c, d), x), ac));\n        return this.AddUnsigned(this.RotateLeft(a, s), b);\n    };\n    Md5.II = function (a, b, c, d, x, s, ac) {\n        a = this.AddUnsigned(a, this.AddUnsigned(this.AddUnsigned(this.I(b, c, d), x), ac));\n        return this.AddUnsigned(this.RotateLeft(a, s), b);\n    };\n    Md5.ConvertToWordArray = function (string) {\n        var lWordCount, lMessageLength = string.length, lNumberOfWords_temp1 = lMessageLength + 8, lNumberOfWords_temp2 = (lNumberOfWords_temp1 - (lNumberOfWords_temp1 % 64)) / 64, lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16, lWordArray = Array(lNumberOfWords - 1), lBytePosition = 0, lByteCount = 0;\n        while (lByteCount < lMessageLength) {\n            lWordCount = (lByteCount - (lByteCount % 4)) / 4;\n            lBytePosition = (lByteCount % 4) * 8;\n            lWordArray[lWordCount] = (lWordArray[lWordCount] | (string.charCodeAt(lByteCount) << lBytePosition));\n            lByteCount++;\n        }\n        lWordCount = (lByteCount - (lByteCount % 4)) / 4;\n        lBytePosition = (lByteCount % 4) * 8;\n        lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80 << lBytePosition);\n        lWordArray[lNumberOfWords - 2] = lMessageLength << 3;\n        lWordArray[lNumberOfWords - 1] = lMessageLength >>> 29;\n        return lWordArray;\n    };\n    Md5.WordToHex = function (lValue) {\n        var WordToHexValue = \"\", WordToHexValue_temp = \"\", lByte, lCount;\n        for (lCount = 0; lCount <= 3; lCount++) {\n            lByte = (lValue >>> (lCount * 8)) & 255;\n            WordToHexValue_temp = \"0\" + lByte.toString(16);\n            WordToHexValue = WordToHexValue + WordToHexValue_temp.substr(WordToHexValue_temp.length - 2, 2);\n        }\n        return WordToHexValue;\n    };\n    Md5.Utf8Encode = function (string) {\n        var utftext = \"\", c;\n        string = string.replace(/\\r\\n/g, \"\\n\");\n        for (var n = 0; n < string.length; n++) {\n            c = string.charCodeAt(n);\n            if (c < 128) {\n                utftext += String.fromCharCode(c);\n            }\n            else if ((c > 127) && (c < 2048)) {\n                utftext += String.fromCharCode((c >> 6) | 192);\n                utftext += String.fromCharCode((c & 63) | 128);\n            }\n            else {\n                utftext += String.fromCharCode((c >> 12) | 224);\n                utftext += String.fromCharCode(((c >> 6) & 63) | 128);\n                utftext += String.fromCharCode((c & 63) | 128);\n            }\n        }\n        return utftext;\n    };\n    Md5.init = function (string) {\n        var temp;\n        if (typeof string !== 'string')\n            string = JSON.stringify(string);\n        this._string = this.Utf8Encode(string);\n        this.x = this.ConvertToWordArray(this._string);\n        this.a = 0x67452301;\n        this.b = 0xEFCDAB89;\n        this.c = 0x98BADCFE;\n        this.d = 0x10325476;\n        for (this.k = 0; this.k < this.x.length; this.k += 16) {\n            this.AA = this.a;\n            this.BB = this.b;\n            this.CC = this.c;\n            this.DD = this.d;\n            this.a = this.FF(this.a, this.b, this.c, this.d, this.x[this.k], this.S11, 0xD76AA478);\n            this.d = this.FF(this.d, this.a, this.b, this.c, this.x[this.k + 1], this.S12, 0xE8C7B756);\n            this.c = this.FF(this.c, this.d, this.a, this.b, this.x[this.k + 2], this.S13, 0x242070DB);\n            this.b = this.FF(this.b, this.c, this.d, this.a, this.x[this.k + 3], this.S14, 0xC1BDCEEE);\n            this.a = this.FF(this.a, this.b, this.c, this.d, this.x[this.k + 4], this.S11, 0xF57C0FAF);\n            this.d = this.FF(this.d, this.a, this.b, this.c, this.x[this.k + 5], this.S12, 0x4787C62A);\n            this.c = this.FF(this.c, this.d, this.a, this.b, this.x[this.k + 6], this.S13, 0xA8304613);\n            this.b = this.FF(this.b, this.c, this.d, this.a, this.x[this.k + 7], this.S14, 0xFD469501);\n            this.a = this.FF(this.a, this.b, this.c, this.d, this.x[this.k + 8], this.S11, 0x698098D8);\n            this.d = this.FF(this.d, this.a, this.b, this.c, this.x[this.k + 9], this.S12, 0x8B44F7AF);\n            this.c = this.FF(this.c, this.d, this.a, this.b, this.x[this.k + 10], this.S13, 0xFFFF5BB1);\n            this.b = this.FF(this.b, this.c, this.d, this.a, this.x[this.k + 11], this.S14, 0x895CD7BE);\n            this.a = this.FF(this.a, this.b, this.c, this.d, this.x[this.k + 12], this.S11, 0x6B901122);\n            this.d = this.FF(this.d, this.a, this.b, this.c, this.x[this.k + 13], this.S12, 0xFD987193);\n            this.c = this.FF(this.c, this.d, this.a, this.b, this.x[this.k + 14], this.S13, 0xA679438E);\n            this.b = this.FF(this.b, this.c, this.d, this.a, this.x[this.k + 15], this.S14, 0x49B40821);\n            this.a = this.GG(this.a, this.b, this.c, this.d, this.x[this.k + 1], this.S21, 0xF61E2562);\n            this.d = this.GG(this.d, this.a, this.b, this.c, this.x[this.k + 6], this.S22, 0xC040B340);\n            this.c = this.GG(this.c, this.d, this.a, this.b, this.x[this.k + 11], this.S23, 0x265E5A51);\n            this.b = this.GG(this.b, this.c, this.d, this.a, this.x[this.k], this.S24, 0xE9B6C7AA);\n            this.a = this.GG(this.a, this.b, this.c, this.d, this.x[this.k + 5], this.S21, 0xD62F105D);\n            this.d = this.GG(this.d, this.a, this.b, this.c, this.x[this.k + 10], this.S22, 0x2441453);\n            this.c = this.GG(this.c, this.d, this.a, this.b, this.x[this.k + 15], this.S23, 0xD8A1E681);\n            this.b = this.GG(this.b, this.c, this.d, this.a, this.x[this.k + 4], this.S24, 0xE7D3FBC8);\n            this.a = this.GG(this.a, this.b, this.c, this.d, this.x[this.k + 9], this.S21, 0x21E1CDE6);\n            this.d = this.GG(this.d, this.a, this.b, this.c, this.x[this.k + 14], this.S22, 0xC33707D6);\n            this.c = this.GG(this.c, this.d, this.a, this.b, this.x[this.k + 3], this.S23, 0xF4D50D87);\n            this.b = this.GG(this.b, this.c, this.d, this.a, this.x[this.k + 8], this.S24, 0x455A14ED);\n            this.a = this.GG(this.a, this.b, this.c, this.d, this.x[this.k + 13], this.S21, 0xA9E3E905);\n            this.d = this.GG(this.d, this.a, this.b, this.c, this.x[this.k + 2], this.S22, 0xFCEFA3F8);\n            this.c = this.GG(this.c, this.d, this.a, this.b, this.x[this.k + 7], this.S23, 0x676F02D9);\n            this.b = this.GG(this.b, this.c, this.d, this.a, this.x[this.k + 12], this.S24, 0x8D2A4C8A);\n            this.a = this.HH(this.a, this.b, this.c, this.d, this.x[this.k + 5], this.S31, 0xFFFA3942);\n            this.d = this.HH(this.d, this.a, this.b, this.c, this.x[this.k + 8], this.S32, 0x8771F681);\n            this.c = this.HH(this.c, this.d, this.a, this.b, this.x[this.k + 11], this.S33, 0x6D9D6122);\n            this.b = this.HH(this.b, this.c, this.d, this.a, this.x[this.k + 14], this.S34, 0xFDE5380C);\n            this.a = this.HH(this.a, this.b, this.c, this.d, this.x[this.k + 1], this.S31, 0xA4BEEA44);\n            this.d = this.HH(this.d, this.a, this.b, this.c, this.x[this.k + 4], this.S32, 0x4BDECFA9);\n            this.c = this.HH(this.c, this.d, this.a, this.b, this.x[this.k + 7], this.S33, 0xF6BB4B60);\n            this.b = this.HH(this.b, this.c, this.d, this.a, this.x[this.k + 10], this.S34, 0xBEBFBC70);\n            this.a = this.HH(this.a, this.b, this.c, this.d, this.x[this.k + 13], this.S31, 0x289B7EC6);\n            this.d = this.HH(this.d, this.a, this.b, this.c, this.x[this.k], this.S32, 0xEAA127FA);\n            this.c = this.HH(this.c, this.d, this.a, this.b, this.x[this.k + 3], this.S33, 0xD4EF3085);\n            this.b = this.HH(this.b, this.c, this.d, this.a, this.x[this.k + 6], this.S34, 0x4881D05);\n            this.a = this.HH(this.a, this.b, this.c, this.d, this.x[this.k + 9], this.S31, 0xD9D4D039);\n            this.d = this.HH(this.d, this.a, this.b, this.c, this.x[this.k + 12], this.S32, 0xE6DB99E5);\n            this.c = this.HH(this.c, this.d, this.a, this.b, this.x[this.k + 15], this.S33, 0x1FA27CF8);\n            this.b = this.HH(this.b, this.c, this.d, this.a, this.x[this.k + 2], this.S34, 0xC4AC5665);\n            this.a = this.II(this.a, this.b, this.c, this.d, this.x[this.k], this.S41, 0xF4292244);\n            this.d = this.II(this.d, this.a, this.b, this.c, this.x[this.k + 7], this.S42, 0x432AFF97);\n            this.c = this.II(this.c, this.d, this.a, this.b, this.x[this.k + 14], this.S43, 0xAB9423A7);\n            this.b = this.II(this.b, this.c, this.d, this.a, this.x[this.k + 5], this.S44, 0xFC93A039);\n            this.a = this.II(this.a, this.b, this.c, this.d, this.x[this.k + 12], this.S41, 0x655B59C3);\n            this.d = this.II(this.d, this.a, this.b, this.c, this.x[this.k + 3], this.S42, 0x8F0CCC92);\n            this.c = this.II(this.c, this.d, this.a, this.b, this.x[this.k + 10], this.S43, 0xFFEFF47D);\n            this.b = this.II(this.b, this.c, this.d, this.a, this.x[this.k + 1], this.S44, 0x85845DD1);\n            this.a = this.II(this.a, this.b, this.c, this.d, this.x[this.k + 8], this.S41, 0x6FA87E4F);\n            this.d = this.II(this.d, this.a, this.b, this.c, this.x[this.k + 15], this.S42, 0xFE2CE6E0);\n            this.c = this.II(this.c, this.d, this.a, this.b, this.x[this.k + 6], this.S43, 0xA3014314);\n            this.b = this.II(this.b, this.c, this.d, this.a, this.x[this.k + 13], this.S44, 0x4E0811A1);\n            this.a = this.II(this.a, this.b, this.c, this.d, this.x[this.k + 4], this.S41, 0xF7537E82);\n            this.d = this.II(this.d, this.a, this.b, this.c, this.x[this.k + 11], this.S42, 0xBD3AF235);\n            this.c = this.II(this.c, this.d, this.a, this.b, this.x[this.k + 2], this.S43, 0x2AD7D2BB);\n            this.b = this.II(this.b, this.c, this.d, this.a, this.x[this.k + 9], this.S44, 0xEB86D391);\n            this.a = this.AddUnsigned(this.a, this.AA);\n            this.b = this.AddUnsigned(this.b, this.BB);\n            this.c = this.AddUnsigned(this.c, this.CC);\n            this.d = this.AddUnsigned(this.d, this.DD);\n        }\n        temp = this.WordToHex(this.a) + this.WordToHex(this.b) + this.WordToHex(this.c) + this.WordToHex(this.d);\n        return temp.toLowerCase();\n    };\n    Md5.x = Array();\n    Md5.S11 = 7;\n    Md5.S12 = 12;\n    Md5.S13 = 17;\n    Md5.S14 = 22;\n    Md5.S21 = 5;\n    Md5.S22 = 9;\n    Md5.S23 = 14;\n    Md5.S24 = 20;\n    Md5.S31 = 4;\n    Md5.S32 = 11;\n    Md5.S33 = 16;\n    Md5.S34 = 23;\n    Md5.S41 = 6;\n    Md5.S42 = 10;\n    Md5.S43 = 15;\n    Md5.S44 = 21;\n    Md5.RotateLeft = function (lValue, iShiftBits) { return (lValue << iShiftBits) | (lValue >>> (32 - iShiftBits)); };\n    Md5.F = function (x, y, z) { return (x & y) | ((~x) & z); };\n    Md5.G = function (x, y, z) { return (x & z) | (y & (~z)); };\n    Md5.H = function (x, y, z) { return (x ^ y ^ z); };\n    Md5.I = function (x, y, z) { return (y ^ (x | (~z))); };\n    return Md5;\n}());\nexport { Md5 };\n//# sourceMappingURL=index.js.map","(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], factory) /* global define */\n  } else if (typeof module === 'object' && module.exports) {\n    module.exports = factory()\n  } else {\n    root.moo = factory()\n  }\n}(this, function() {\n  'use strict';\n\n  var hasOwnProperty = Object.prototype.hasOwnProperty\n  var toString = Object.prototype.toString\n  var hasSticky = typeof new RegExp().sticky === 'boolean'\n\n  /***************************************************************************/\n\n  function isRegExp(o) { return o && toString.call(o) === '[object RegExp]' }\n  function isObject(o) { return o && typeof o === 'object' && !isRegExp(o) && !Array.isArray(o) }\n\n  function reEscape(s) {\n    return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\n  }\n  function reGroups(s) {\n    var re = new RegExp('|' + s)\n    return re.exec('').length - 1\n  }\n  function reCapture(s) {\n    return '(' + s + ')'\n  }\n  function reUnion(regexps) {\n    if (!regexps.length) return '(?!)'\n    var source =  regexps.map(function(s) {\n      return \"(?:\" + s + \")\"\n    }).join('|')\n    return \"(?:\" + source + \")\"\n  }\n\n  function regexpOrLiteral(obj) {\n    if (typeof obj === 'string') {\n      return '(?:' + reEscape(obj) + ')'\n\n    } else if (isRegExp(obj)) {\n      // TODO: consider /u support\n      if (obj.ignoreCase) throw new Error('RegExp /i flag not allowed')\n      if (obj.global) throw new Error('RegExp /g flag is implied')\n      if (obj.sticky) throw new Error('RegExp /y flag is implied')\n      if (obj.multiline) throw new Error('RegExp /m flag is implied')\n      return obj.source\n\n    } else {\n      throw new Error('Not a pattern: ' + obj)\n    }\n  }\n\n  function objectToRules(object) {\n    var keys = Object.getOwnPropertyNames(object)\n    var result = []\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      var thing = object[key]\n      var rules = [].concat(thing)\n      if (key === 'include') {\n        for (var j = 0; j < rules.length; j++) {\n          result.push({include: rules[j]})\n        }\n        continue\n      }\n      var match = []\n      rules.forEach(function(rule) {\n        if (isObject(rule)) {\n          if (match.length) result.push(ruleOptions(key, match))\n          result.push(ruleOptions(key, rule))\n          match = []\n        } else {\n          match.push(rule)\n        }\n      })\n      if (match.length) result.push(ruleOptions(key, match))\n    }\n    return result\n  }\n\n  function arrayToRules(array) {\n    var result = []\n    for (var i = 0; i < array.length; i++) {\n      var obj = array[i]\n      if (obj.include) {\n        var include = [].concat(obj.include)\n        for (var j = 0; j < include.length; j++) {\n          result.push({include: include[j]})\n        }\n        continue\n      }\n      if (!obj.type) {\n        throw new Error('Rule has no type: ' + JSON.stringify(obj))\n      }\n      result.push(ruleOptions(obj.type, obj))\n    }\n    return result\n  }\n\n  function ruleOptions(type, obj) {\n    if (!isObject(obj)) {\n      obj = { match: obj }\n    }\n    if (obj.include) {\n      throw new Error('Matching rules cannot also include states')\n    }\n\n    // nb. error and fallback imply lineBreaks\n    var options = {\n      defaultType: type,\n      lineBreaks: !!obj.error || !!obj.fallback,\n      pop: false,\n      next: null,\n      push: null,\n      error: false,\n      fallback: false,\n      value: null,\n      type: null,\n      shouldThrow: false,\n    }\n\n    // Avoid Object.assign(), so we support IE9+\n    for (var key in obj) {\n      if (hasOwnProperty.call(obj, key)) {\n        options[key] = obj[key]\n      }\n    }\n\n    // type transform cannot be a string\n    if (typeof options.type === 'string' && type !== options.type) {\n      throw new Error(\"Type transform cannot be a string (type '\" + options.type + \"' for token '\" + type + \"')\")\n    }\n\n    // convert to array\n    var match = options.match\n    options.match = Array.isArray(match) ? match : match ? [match] : []\n    options.match.sort(function(a, b) {\n      return isRegExp(a) && isRegExp(b) ? 0\n           : isRegExp(b) ? -1 : isRegExp(a) ? +1 : b.length - a.length\n    })\n    return options\n  }\n\n  function toRules(spec) {\n    return Array.isArray(spec) ? arrayToRules(spec) : objectToRules(spec)\n  }\n\n  var defaultErrorRule = ruleOptions('error', {lineBreaks: true, shouldThrow: true})\n  function compileRules(rules, hasStates) {\n    var errorRule = null\n    var fast = Object.create(null)\n    var fastAllowed = true\n    var unicodeFlag = null\n    var groups = []\n    var parts = []\n\n    // If there is a fallback rule, then disable fast matching\n    for (var i = 0; i < rules.length; i++) {\n      if (rules[i].fallback) {\n        fastAllowed = false\n      }\n    }\n\n    for (var i = 0; i < rules.length; i++) {\n      var options = rules[i]\n\n      if (options.include) {\n        // all valid inclusions are removed by states() preprocessor\n        throw new Error('Inheritance is not allowed in stateless lexers')\n      }\n\n      if (options.error || options.fallback) {\n        // errorRule can only be set once\n        if (errorRule) {\n          if (!options.fallback === !errorRule.fallback) {\n            throw new Error(\"Multiple \" + (options.fallback ? \"fallback\" : \"error\") + \" rules not allowed (for token '\" + options.defaultType + \"')\")\n          } else {\n            throw new Error(\"fallback and error are mutually exclusive (for token '\" + options.defaultType + \"')\")\n          }\n        }\n        errorRule = options\n      }\n\n      var match = options.match.slice()\n      if (fastAllowed) {\n        while (match.length && typeof match[0] === 'string' && match[0].length === 1) {\n          var word = match.shift()\n          fast[word.charCodeAt(0)] = options\n        }\n      }\n\n      // Warn about inappropriate state-switching options\n      if (options.pop || options.push || options.next) {\n        if (!hasStates) {\n          throw new Error(\"State-switching options are not allowed in stateless lexers (for token '\" + options.defaultType + \"')\")\n        }\n        if (options.fallback) {\n          throw new Error(\"State-switching options are not allowed on fallback tokens (for token '\" + options.defaultType + \"')\")\n        }\n      }\n\n      // Only rules with a .match are included in the RegExp\n      if (match.length === 0) {\n        continue\n      }\n      fastAllowed = false\n\n      groups.push(options)\n\n      // Check unicode flag is used everywhere or nowhere\n      for (var j = 0; j < match.length; j++) {\n        var obj = match[j]\n        if (!isRegExp(obj)) {\n          continue\n        }\n\n        if (unicodeFlag === null) {\n          unicodeFlag = obj.unicode\n        } else if (unicodeFlag !== obj.unicode && options.fallback === false) {\n          throw new Error('If one rule is /u then all must be')\n        }\n      }\n\n      // convert to RegExp\n      var pat = reUnion(match.map(regexpOrLiteral))\n\n      // validate\n      var regexp = new RegExp(pat)\n      if (regexp.test(\"\")) {\n        throw new Error(\"RegExp matches empty string: \" + regexp)\n      }\n      var groupCount = reGroups(pat)\n      if (groupCount > 0) {\n        throw new Error(\"RegExp has capture groups: \" + regexp + \"\\nUse (?: … ) instead\")\n      }\n\n      // try and detect rules matching newlines\n      if (!options.lineBreaks && regexp.test('\\n')) {\n        throw new Error('Rule should declare lineBreaks: ' + regexp)\n      }\n\n      // store regex\n      parts.push(reCapture(pat))\n    }\n\n\n    // If there's no fallback rule, use the sticky flag so we only look for\n    // matches at the current index.\n    //\n    // If we don't support the sticky flag, then fake it using an irrefutable\n    // match (i.e. an empty pattern).\n    var fallbackRule = errorRule && errorRule.fallback\n    var flags = hasSticky && !fallbackRule ? 'ym' : 'gm'\n    var suffix = hasSticky || fallbackRule ? '' : '|'\n\n    if (unicodeFlag === true) flags += \"u\"\n    var combined = new RegExp(reUnion(parts) + suffix, flags)\n    return {regexp: combined, groups: groups, fast: fast, error: errorRule || defaultErrorRule}\n  }\n\n  function compile(rules) {\n    var result = compileRules(toRules(rules))\n    return new Lexer({start: result}, 'start')\n  }\n\n  function checkStateGroup(g, name, map) {\n    var state = g && (g.push || g.next)\n    if (state && !map[state]) {\n      throw new Error(\"Missing state '\" + state + \"' (in token '\" + g.defaultType + \"' of state '\" + name + \"')\")\n    }\n    if (g && g.pop && +g.pop !== 1) {\n      throw new Error(\"pop must be 1 (in token '\" + g.defaultType + \"' of state '\" + name + \"')\")\n    }\n  }\n  function compileStates(states, start) {\n    var all = states.$all ? toRules(states.$all) : []\n    delete states.$all\n\n    var keys = Object.getOwnPropertyNames(states)\n    if (!start) start = keys[0]\n\n    var ruleMap = Object.create(null)\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      ruleMap[key] = toRules(states[key]).concat(all)\n    }\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      var rules = ruleMap[key]\n      var included = Object.create(null)\n      for (var j = 0; j < rules.length; j++) {\n        var rule = rules[j]\n        if (!rule.include) continue\n        var splice = [j, 1]\n        if (rule.include !== key && !included[rule.include]) {\n          included[rule.include] = true\n          var newRules = ruleMap[rule.include]\n          if (!newRules) {\n            throw new Error(\"Cannot include nonexistent state '\" + rule.include + \"' (in state '\" + key + \"')\")\n          }\n          for (var k = 0; k < newRules.length; k++) {\n            var newRule = newRules[k]\n            if (rules.indexOf(newRule) !== -1) continue\n            splice.push(newRule)\n          }\n        }\n        rules.splice.apply(rules, splice)\n        j--\n      }\n    }\n\n    var map = Object.create(null)\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      map[key] = compileRules(ruleMap[key], true)\n    }\n\n    for (var i = 0; i < keys.length; i++) {\n      var name = keys[i]\n      var state = map[name]\n      var groups = state.groups\n      for (var j = 0; j < groups.length; j++) {\n        checkStateGroup(groups[j], name, map)\n      }\n      var fastKeys = Object.getOwnPropertyNames(state.fast)\n      for (var j = 0; j < fastKeys.length; j++) {\n        checkStateGroup(state.fast[fastKeys[j]], name, map)\n      }\n    }\n\n    return new Lexer(map, start)\n  }\n\n  function keywordTransform(map) {\n    var reverseMap = Object.create(null)\n    var byLength = Object.create(null)\n    var types = Object.getOwnPropertyNames(map)\n    for (var i = 0; i < types.length; i++) {\n      var tokenType = types[i]\n      var item = map[tokenType]\n      var keywordList = Array.isArray(item) ? item : [item]\n      keywordList.forEach(function(keyword) {\n        (byLength[keyword.length] = byLength[keyword.length] || []).push(keyword)\n        if (typeof keyword !== 'string') {\n          throw new Error(\"keyword must be string (in keyword '\" + tokenType + \"')\")\n        }\n        reverseMap[keyword] = tokenType\n      })\n    }\n\n    // fast string lookup\n    // https://jsperf.com/string-lookups\n    function str(x) { return JSON.stringify(x) }\n    var source = ''\n    source += 'switch (value.length) {\\n'\n    for (var length in byLength) {\n      var keywords = byLength[length]\n      source += 'case ' + length + ':\\n'\n      source += 'switch (value) {\\n'\n      keywords.forEach(function(keyword) {\n        var tokenType = reverseMap[keyword]\n        source += 'case ' + str(keyword) + ': return ' + str(tokenType) + '\\n'\n      })\n      source += '}\\n'\n    }\n    source += '}\\n'\n    return Function('value', source) // type\n  }\n\n  /***************************************************************************/\n\n  var Lexer = function(states, state) {\n    this.startState = state\n    this.states = states\n    this.buffer = ''\n    this.stack = []\n    this.reset()\n  }\n\n  Lexer.prototype.reset = function(data, info) {\n    this.buffer = data || ''\n    this.index = 0\n    this.line = info ? info.line : 1\n    this.col = info ? info.col : 1\n    this.queuedToken = info ? info.queuedToken : null\n    this.queuedThrow = info ? info.queuedThrow : null\n    this.setState(info ? info.state : this.startState)\n    this.stack = info && info.stack ? info.stack.slice() : []\n    return this\n  }\n\n  Lexer.prototype.save = function() {\n    return {\n      line: this.line,\n      col: this.col,\n      state: this.state,\n      stack: this.stack.slice(),\n      queuedToken: this.queuedToken,\n      queuedThrow: this.queuedThrow,\n    }\n  }\n\n  Lexer.prototype.setState = function(state) {\n    if (!state || this.state === state) return\n    this.state = state\n    var info = this.states[state]\n    this.groups = info.groups\n    this.error = info.error\n    this.re = info.regexp\n    this.fast = info.fast\n  }\n\n  Lexer.prototype.popState = function() {\n    this.setState(this.stack.pop())\n  }\n\n  Lexer.prototype.pushState = function(state) {\n    this.stack.push(this.state)\n    this.setState(state)\n  }\n\n  var eat = hasSticky ? function(re, buffer) { // assume re is /y\n    return re.exec(buffer)\n  } : function(re, buffer) { // assume re is /g\n    var match = re.exec(buffer)\n    // will always match, since we used the |(?:) trick\n    if (match[0].length === 0) {\n      return null\n    }\n    return match\n  }\n\n  Lexer.prototype._getGroup = function(match) {\n    var groupCount = this.groups.length\n    for (var i = 0; i < groupCount; i++) {\n      if (match[i + 1] !== undefined) {\n        return this.groups[i]\n      }\n    }\n    throw new Error('Cannot find token type for matched text')\n  }\n\n  function tokenToString() {\n    return this.value\n  }\n\n  Lexer.prototype.next = function() {\n    var index = this.index\n\n    // If a fallback token matched, we don't need to re-run the RegExp\n    if (this.queuedGroup) {\n      var token = this._token(this.queuedGroup, this.queuedText, index)\n      this.queuedGroup = null\n      this.queuedText = \"\"\n      return token\n    }\n\n    var buffer = this.buffer\n    if (index === buffer.length) {\n      return // EOF\n    }\n\n    // Fast matching for single characters\n    var group = this.fast[buffer.charCodeAt(index)]\n    if (group) {\n      return this._token(group, buffer.charAt(index), index)\n    }\n\n    // Execute RegExp\n    var re = this.re\n    re.lastIndex = index\n    var match = eat(re, buffer)\n\n    // Error tokens match the remaining buffer\n    var error = this.error\n    if (match == null) {\n      return this._token(error, buffer.slice(index, buffer.length), index)\n    }\n\n    var group = this._getGroup(match)\n    var text = match[0]\n\n    if (error.fallback && match.index !== index) {\n      this.queuedGroup = group\n      this.queuedText = text\n\n      // Fallback tokens contain the unmatched portion of the buffer\n      return this._token(error, buffer.slice(index, match.index), index)\n    }\n\n    return this._token(group, text, index)\n  }\n\n  Lexer.prototype._token = function(group, text, offset) {\n    // count line breaks\n    var lineBreaks = 0\n    if (group.lineBreaks) {\n      var matchNL = /\\n/g\n      var nl = 1\n      if (text === '\\n') {\n        lineBreaks = 1\n      } else {\n        while (matchNL.exec(text)) { lineBreaks++; nl = matchNL.lastIndex }\n      }\n    }\n\n    var token = {\n      type: (typeof group.type === 'function' && group.type(text)) || group.defaultType,\n      value: typeof group.value === 'function' ? group.value(text) : text,\n      text: text,\n      toString: tokenToString,\n      offset: offset,\n      lineBreaks: lineBreaks,\n      line: this.line,\n      col: this.col,\n    }\n    // nb. adding more props to token object will make V8 sad!\n\n    var size = text.length\n    this.index += size\n    this.line += lineBreaks\n    if (lineBreaks !== 0) {\n      this.col = size - nl + 1\n    } else {\n      this.col += size\n    }\n\n    // throw, if no rule with {error: true}\n    if (group.shouldThrow) {\n      throw new Error(this.formatError(token, \"invalid syntax\"))\n    }\n\n    if (group.pop) this.popState()\n    else if (group.push) this.pushState(group.push)\n    else if (group.next) this.setState(group.next)\n\n    return token\n  }\n\n  if (typeof Symbol !== 'undefined' && Symbol.iterator) {\n    var LexerIterator = function(lexer) {\n      this.lexer = lexer\n    }\n\n    LexerIterator.prototype.next = function() {\n      var token = this.lexer.next()\n      return {value: token, done: !token}\n    }\n\n    LexerIterator.prototype[Symbol.iterator] = function() {\n      return this\n    }\n\n    Lexer.prototype[Symbol.iterator] = function() {\n      return new LexerIterator(this)\n    }\n  }\n\n  Lexer.prototype.formatError = function(token, message) {\n    if (token == null) {\n      // An undefined token indicates EOF\n      var text = this.buffer.slice(this.index)\n      var token = {\n        text: text,\n        offset: this.index,\n        lineBreaks: text.indexOf('\\n') === -1 ? 0 : 1,\n        line: this.line,\n        col: this.col,\n      }\n    }\n    var start = Math.max(0, token.offset - token.col + 1)\n    var eol = token.lineBreaks ? token.text.indexOf('\\n') : token.text.length\n    var firstLine = this.buffer.substring(start, token.offset + eol)\n    message += \" at line \" + token.line + \" col \" + token.col + \":\\n\\n\"\n    message += \"  \" + firstLine + \"\\n\"\n    message += \"  \" + Array(token.col).join(\" \") + \"^\"\n    return message\n  }\n\n  Lexer.prototype.clone = function() {\n    return new Lexer(this.states, this.state)\n  }\n\n  Lexer.prototype.has = function(tokenType) {\n    return true\n  }\n\n\n  return {\n    compile: compile,\n    states: compileStates,\n    error: Object.freeze({error: true}),\n    fallback: Object.freeze({fallback: true}),\n    keywords: keywordTransform,\n  }\n\n}));\n","// Generated automatically by nearley, version unknown\n// http://github.com/Hardmath123/nearley\n(function () {\nfunction id(x) { return x[0]; }\n\nconst moo = require(\"moo\");\nconst lexer = moo.compile({\n  space: {match: /\\s+/, lineBreaks: true},\n  number: /-?(?:[0-9]|[1-9][0-9]+)(?:\\.[0-9]+)?(?:[eE][-+]?[0-9]+)?\\b/,\n  comment: /#[^\\n]*/,\n  '[': '[',\n  ']': ']',\n  assignment: /=[^\\n]*/,\n  // Leading underscores are disallowed in field names, while constant names have no explicit restrictions.\n  // So we are more lenient in lexing here, and the validation steps below are more strict.\n  // See: https://github.com/ros/genmsg/blob/7d8b6ce6f43b6e39ea8261125d270f2d3062356f/src/genmsg/msg_loader.py#L188-L238\n  fieldOrType: /[a-zA-Z_][a-zA-Z0-9_]*(?:\\/[a-zA-Z][a-zA-Z0-9_]*)?/,\n});\n\n\nfunction extend(objs) {\n  return objs.reduce((r, p) => ({ ...r, ...p }), {});\n}\nvar grammar = {\n    Lexer: lexer,\n    ParserRules: [\n    {\"name\": \"main$ebnf$1\", \"symbols\": [\"comment\"], \"postprocess\": id},\n    {\"name\": \"main$ebnf$1\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"main\", \"symbols\": [\"_\", \"boolType\", \"arrayType\", \"__\", \"field\", \"_\", \"main$ebnf$1\", \"simple\"], \"postprocess\": function(d) { return extend(d) }},\n    {\"name\": \"main$ebnf$2\", \"symbols\": [\"comment\"], \"postprocess\": id},\n    {\"name\": \"main$ebnf$2\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"main\", \"symbols\": [\"_\", \"bigintType\", \"arrayType\", \"__\", \"field\", \"_\", \"main$ebnf$2\", \"simple\"], \"postprocess\": function(d) { return extend(d) }},\n    {\"name\": \"main$ebnf$3\", \"symbols\": [\"comment\"], \"postprocess\": id},\n    {\"name\": \"main$ebnf$3\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"main\", \"symbols\": [\"_\", \"numericType\", \"arrayType\", \"__\", \"field\", \"_\", \"main$ebnf$3\", \"simple\"], \"postprocess\": function(d) { return extend(d) }},\n    {\"name\": \"main$ebnf$4\", \"symbols\": [\"comment\"], \"postprocess\": id},\n    {\"name\": \"main$ebnf$4\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"main\", \"symbols\": [\"_\", \"stringType\", \"arrayType\", \"__\", \"field\", \"_\", \"main$ebnf$4\", \"simple\"], \"postprocess\": function(d) { return extend(d) }},\n    {\"name\": \"main$ebnf$5\", \"symbols\": [\"comment\"], \"postprocess\": id},\n    {\"name\": \"main$ebnf$5\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"main\", \"symbols\": [\"_\", \"timeType\", \"arrayType\", \"__\", \"field\", \"_\", \"main$ebnf$5\", \"simple\"], \"postprocess\": function(d) { return extend(d) }},\n    {\"name\": \"main$ebnf$6\", \"symbols\": [\"comment\"], \"postprocess\": id},\n    {\"name\": \"main$ebnf$6\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"main\", \"symbols\": [\"_\", \"customType\", \"arrayType\", \"__\", \"field\", \"_\", \"main$ebnf$6\", \"complex\"], \"postprocess\": function(d) { return extend(d) }},\n    {\"name\": \"main$ebnf$7\", \"symbols\": [\"comment\"], \"postprocess\": id},\n    {\"name\": \"main$ebnf$7\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"main\", \"symbols\": [\"_\", \"boolType\", \"__\", \"constantField\", \"_\", \"boolConstantValue\", \"_\", \"main$ebnf$7\"], \"postprocess\": function(d) { return extend(d) }},\n    {\"name\": \"main$ebnf$8\", \"symbols\": [\"comment\"], \"postprocess\": id},\n    {\"name\": \"main$ebnf$8\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"main\", \"symbols\": [\"_\", \"bigintType\", \"__\", \"constantField\", \"_\", \"bigintConstantValue\", \"_\", \"main$ebnf$8\"], \"postprocess\": function(d) { return extend(d) }},\n    {\"name\": \"main$ebnf$9\", \"symbols\": [\"comment\"], \"postprocess\": id},\n    {\"name\": \"main$ebnf$9\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"main\", \"symbols\": [\"_\", \"numericType\", \"__\", \"constantField\", \"_\", \"numericConstantValue\", \"_\", \"main$ebnf$9\"], \"postprocess\": function(d) { return extend(d) }},\n    {\"name\": \"main$ebnf$10\", \"symbols\": [\"comment\"], \"postprocess\": id},\n    {\"name\": \"main$ebnf$10\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"main\", \"symbols\": [\"_\", \"stringType\", \"__\", \"constantField\", \"_\", \"stringConstantValue\", \"_\", \"main$ebnf$10\"], \"postprocess\": function(d) { return extend(d) }},\n    {\"name\": \"main\", \"symbols\": [\"comment\"], \"postprocess\": function(d) { return null }},\n    {\"name\": \"main\", \"symbols\": [\"blankLine\"], \"postprocess\": function(d) { return null }},\n    {\"name\": \"boolType\", \"symbols\": [{\"literal\":\"bool\"}], \"postprocess\": function(d) { return { type: d[0].value } }},\n    {\"name\": \"bigintType$subexpression$1\", \"symbols\": [{\"literal\":\"int64\"}]},\n    {\"name\": \"bigintType$subexpression$1\", \"symbols\": [{\"literal\":\"uint64\"}]},\n    {\"name\": \"bigintType\", \"symbols\": [\"bigintType$subexpression$1\"], \"postprocess\": function(d) { return { type: d[0][0].value } }},\n    {\"name\": \"numericType$subexpression$1\", \"symbols\": [{\"literal\":\"byte\"}]},\n    {\"name\": \"numericType$subexpression$1\", \"symbols\": [{\"literal\":\"char\"}]},\n    {\"name\": \"numericType$subexpression$1\", \"symbols\": [{\"literal\":\"float32\"}]},\n    {\"name\": \"numericType$subexpression$1\", \"symbols\": [{\"literal\":\"float64\"}]},\n    {\"name\": \"numericType$subexpression$1\", \"symbols\": [{\"literal\":\"int8\"}]},\n    {\"name\": \"numericType$subexpression$1\", \"symbols\": [{\"literal\":\"uint8\"}]},\n    {\"name\": \"numericType$subexpression$1\", \"symbols\": [{\"literal\":\"int16\"}]},\n    {\"name\": \"numericType$subexpression$1\", \"symbols\": [{\"literal\":\"uint16\"}]},\n    {\"name\": \"numericType$subexpression$1\", \"symbols\": [{\"literal\":\"int32\"}]},\n    {\"name\": \"numericType$subexpression$1\", \"symbols\": [{\"literal\":\"uint32\"}]},\n    {\"name\": \"numericType\", \"symbols\": [\"numericType$subexpression$1\"], \"postprocess\": function(d) { return { type: d[0][0].value } }},\n    {\"name\": \"stringType\", \"symbols\": [{\"literal\":\"string\"}], \"postprocess\": function(d) { return { type: d[0].value } }},\n    {\"name\": \"timeType$subexpression$1\", \"symbols\": [{\"literal\":\"time\"}]},\n    {\"name\": \"timeType$subexpression$1\", \"symbols\": [{\"literal\":\"duration\"}]},\n    {\"name\": \"timeType\", \"symbols\": [\"timeType$subexpression$1\"], \"postprocess\": function(d) { return { type: d[0][0].value } }},\n    {\"name\": \"customType\", \"symbols\": [(lexer.has(\"fieldOrType\") ? {type: \"fieldOrType\"} : fieldOrType)], \"postprocess\":  function(d, _, reject) {\n          const PRIMITIVE_TYPES = [\"bool\", \"byte\", \"char\", \"float32\", \"float64\", \"int8\", \"uint8\", \"int16\", \"uint16\", \"int32\", \"uint32\", \"int64\", \"uint64\", \"string\", \"time\", \"duration\"];\n          const type = d[0].value;\n          if (PRIMITIVE_TYPES.includes(type)) return reject;\n          return { type };\n        } },\n    {\"name\": \"arrayType\", \"symbols\": [{\"literal\":\"[\"}, \"_\", {\"literal\":\"]\"}], \"postprocess\": function(d) { return { isArray: true } }},\n    {\"name\": \"arrayType\", \"symbols\": [{\"literal\":\"[\"}, \"_\", \"number\", \"_\", {\"literal\":\"]\"}], \"postprocess\": function(d) { return { isArray: true, arrayLength: d[2] } }},\n    {\"name\": \"arrayType\", \"symbols\": [\"_\"], \"postprocess\": function(d) { return { isArray: false } }},\n    {\"name\": \"field\", \"symbols\": [(lexer.has(\"fieldOrType\") ? {type: \"fieldOrType\"} : fieldOrType)], \"postprocess\":  function(d, _, reject) {\n          const name = d[0].value;\n          // Leading underscores or digits are not allowed in field names\n          if (name.match(/^[a-zA-Z][a-zA-Z0-9_]*$/) == undefined) return reject;\n          return { name };\n        } },\n    {\"name\": \"constantField\", \"symbols\": [(lexer.has(\"fieldOrType\") ? {type: \"fieldOrType\"} : fieldOrType)], \"postprocess\":  function(d, _, reject) {\n          const name = d[0].value;\n          // Leading digits are not allowed in constant names (the ROS genmsg parser\n          // allows them, but loading the generated Python code fails later)\n          if (name.match(/^[a-zA-Z_][a-zA-Z0-9_]*$/) == undefined) return reject;\n          return { name, isConstant: true };\n        } },\n    {\"name\": \"boolConstantValue\", \"symbols\": [\"assignment\"], \"postprocess\":  function(d, _, reject) {\n          const valueText = d[0].split(\"#\")[0].trim();\n          if (valueText === \"True\" || valueText === \"1\") return { value: true, valueText };\n          if (valueText === \"False\" || valueText === \"0\") return { value: false, valueText };\n          return reject;\n        } },\n    {\"name\": \"numericConstantValue\", \"symbols\": [\"assignment\"], \"postprocess\":  function(d, _, reject) {\n          const valueText = d[0].split(\"#\")[0].trim();\n          const value = parseFloat(valueText);\n          return !isNaN(value) ? { value, valueText } : reject;\n        } },\n    {\"name\": \"bigintConstantValue\", \"symbols\": [\"assignment\"], \"postprocess\":  function(d, _, reject) {\n          const valueText = d[0].split(\"#\")[0].trim();\n          try {\n            const value = BigInt(valueText);\n            return { value, valueText };\n          } catch {\n            return reject;\n          }\n        } },\n    {\"name\": \"stringConstantValue\", \"symbols\": [\"assignment\"], \"postprocess\": function(d) { return { value: d[0], valueText: d[0] } }},\n    {\"name\": \"bool$subexpression$1\", \"symbols\": [{\"literal\":\"True\"}]},\n    {\"name\": \"bool$subexpression$1\", \"symbols\": [{\"literal\":\"1\"}]},\n    {\"name\": \"bool\", \"symbols\": [\"bool$subexpression$1\"], \"postprocess\": function(d) { return true }},\n    {\"name\": \"bool$subexpression$2\", \"symbols\": [{\"literal\":\"False\"}]},\n    {\"name\": \"bool$subexpression$2\", \"symbols\": [{\"literal\":\"0\"}]},\n    {\"name\": \"bool\", \"symbols\": [\"bool$subexpression$2\"], \"postprocess\": function(d) { return false }},\n    {\"name\": \"number\", \"symbols\": [(lexer.has(\"number\") ? {type: \"number\"} : number)], \"postprocess\": function(d) { return parseFloat(d[0].value) }},\n    {\"name\": \"assignment\", \"symbols\": [(lexer.has(\"assignment\") ? {type: \"assignment\"} : assignment)], \"postprocess\": function(d) { return d[0].value.substr(1).trim() }},\n    {\"name\": \"comment\", \"symbols\": [(lexer.has(\"comment\") ? {type: \"comment\"} : comment)], \"postprocess\": function(d) { return null }},\n    {\"name\": \"blankLine\", \"symbols\": [\"_\"], \"postprocess\": function(d) { return null }},\n    {\"name\": \"_$subexpression$1\", \"symbols\": []},\n    {\"name\": \"_$subexpression$1\", \"symbols\": [(lexer.has(\"space\") ? {type: \"space\"} : space)]},\n    {\"name\": \"_\", \"symbols\": [\"_$subexpression$1\"], \"postprocess\": function(d) { return null }},\n    {\"name\": \"__\", \"symbols\": [(lexer.has(\"space\") ? {type: \"space\"} : space)], \"postprocess\": function(d) { return null }},\n    {\"name\": \"simple\", \"symbols\": [], \"postprocess\": function() { return { isComplex: false } }},\n    {\"name\": \"complex\", \"symbols\": [], \"postprocess\": function() { return { isComplex: true } }}\n]\n  , ParserStart: \"main\"\n}\nif (typeof module !== 'undefined'&& typeof module.exports !== 'undefined') {\n   module.exports = grammar;\n} else {\n   window.grammar = grammar;\n}\n})();\n","// Generated automatically by nearley, version unknown\n// http://github.com/Hardmath123/nearley\n(function () {\nfunction id(x) { return x[0]; }\n\n\n// necessary to use keywords to avoid using the `reject` postprocessor which can cause poor perf\n// having these as keywords removes ambiguity with `customType` rule\nconst keywords = [\n  , \"struct\"\n  , \"module\"\n  , \"const\"\n  , \"include\"\n  , \"typedef\"\n\n  //types\n  , \"boolean\"\n  , \"wstring\"\n  , \"string\"\n  , \"sequence\"\n\n  // Boolean types\n  , \"TRUE\"\n  , \"FALSE\"\n  \n  // numeric types\n  , \"byte\"\n  , \"octet\"\n  , \"wchar\"\n  , \"char\"\n  , \"double\"\n  , \"float\"\n  , \"int8\"\n  , \"uint8\"\n  , \"int16\"\n  , \"uint16\"\n  , \"int32\"\n  , \"uint32\"\n  , \"int64\"\n  , \"uint64\"\n  , \"unsigned\" \n  , \"short\"  \n  , \"long\"\n];\n\nconst kwObject = keywords.reduce((obj, w) => {\n  obj[w] = w;\n  return obj;\n}, {});\n\nconst moo = require(\"moo\");\n// Terminal tokens are in all caps\nconst lexer = moo.compile({\n  SPACE: {match: /\\s+/, lineBreaks: true},\n  DECIMALEXP: /(?:(?:\\d+\\.\\d*)|(?:\\d*\\.\\d+)|(?:[0-9]+))[eE](?:[+|-])?[0-9]+/,\n  DECIMAL: /(?:(?:\\d+\\.\\d*)|(?:\\d*\\.\\d+))/,\n  INTEGER: /\\d+/,\n  COMMENT: /(?:\\/\\/[^\\n]*)|(?:\\/\\*(?:.|\\n)+?\\*\\/)/,\n  HEX_LITERAL: /0x(?:[0-9a-fA-F])+?/,\n  STRING: {match: /\"(?:\\\\[\"\\\\rnu]|[^\"\\\\])*\"/, value: x => x.slice(1, -1)}, // remove outside quotes\n  LCBR: '{',\n  RCBR: '}',\n  LBR: '[',\n  RBR: ']',\n  LT: '<',\n  GT: '>',\n  LPAR: '(',\n  RPAR: ')',\n  ';': ';',\n  ',': ',',\n  AT: '@',\n  PND: '#',\n  PT: \".\",\n  '/': \"/\",\n  SIGN: /[+-]/,\n  HEADER: /={80}\\nIDL: [a-zA-Z][\\w]+(?:\\/[a-zA-Z][\\w]+)*/,\n  EQ: /=[^\\n]*?/,\n  NAME: {match: /[a-zA-Z_][a-zA-Z0-9_]*(?:\\:\\:[a-zA-Z][a-zA-Z0-9_]*)*/, type: moo.keywords(kwObject)},\n});\n\n// Ignore whitespace and comment tokens\nconst tokensToIgnore = ['SPACE', 'COMMENT'];\n// requires us to override the lexer's next function \nlexer.next = (next => () => {\n  let token;\n  while ((token = next.call(lexer)) && tokensToIgnore.includes(token.type)) {}\n  return token;\n})(lexer.next);\n\n// Utiility functions\n\nconst numericTypeMap = {\n  \"unsigned short\": \"uint16\",\n  \"unsigned long\": \"uint32\",\n  \"unsigned long long\": \"uint64\",\n  \"short\": \"int16\",\n  \"long\": \"int32\",\n  \"long long\": \"int64\",\n  \"double\": \"float64\",\n  \"float\": \"float32\",\n  \"octet\": \"byte\",\n  \"wchar\": \"char\",\n};\n\n// also used to parse tokens to strings since they start as an object\nfunction join(d){\n  return d.join(\"\");\n}\n\n// used for combining AST components\nfunction extend(objs) {\n  return objs.reduce((r, p) => ({ ...r, ...p }), {});\n}\n\nfunction noop() {\n  return null;\n}\n\nfunction getIntOrConstantValue(d) {\n  const int = parseInt(d);\n  if(!isNaN(int)) {\n    return int;\n  }\n\n  // handle %NAME token\n  return d?.value ? {usesConstant: true, name: d.value} : undefined;  \n}\n\nfunction aggregateConstantUsage(dcl) {\n  const entries = Object.entries(dcl).filter(\n    ([key, value]) => value?.usesConstant === true\n  ).map(([key, {name}]) => ([key, name]));\n  return {\n    ...dcl,\n    constantUsage: entries,\n  };\n}\nvar grammar = {\n    Lexer: lexer,\n    ParserRules: [\n    {\"name\": \"main$ebnf$1$subexpression$1$ebnf$1\", \"symbols\": [\"header\"], \"postprocess\": id},\n    {\"name\": \"main$ebnf$1$subexpression$1$ebnf$1\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"main$ebnf$1$subexpression$1$ebnf$2\", \"symbols\": []},\n    {\"name\": \"main$ebnf$1$subexpression$1$ebnf$2\", \"symbols\": [\"main$ebnf$1$subexpression$1$ebnf$2\", \"importDcl\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"main$ebnf$1$subexpression$1$ebnf$3\", \"symbols\": [\"definition\"]},\n    {\"name\": \"main$ebnf$1$subexpression$1$ebnf$3\", \"symbols\": [\"main$ebnf$1$subexpression$1$ebnf$3\", \"definition\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"main$ebnf$1$subexpression$1\", \"symbols\": [\"main$ebnf$1$subexpression$1$ebnf$1\", \"main$ebnf$1$subexpression$1$ebnf$2\", \"main$ebnf$1$subexpression$1$ebnf$3\"]},\n    {\"name\": \"main$ebnf$1\", \"symbols\": [\"main$ebnf$1$subexpression$1\"]},\n    {\"name\": \"main$ebnf$1$subexpression$2$ebnf$1\", \"symbols\": [\"header\"], \"postprocess\": id},\n    {\"name\": \"main$ebnf$1$subexpression$2$ebnf$1\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"main$ebnf$1$subexpression$2$ebnf$2\", \"symbols\": []},\n    {\"name\": \"main$ebnf$1$subexpression$2$ebnf$2\", \"symbols\": [\"main$ebnf$1$subexpression$2$ebnf$2\", \"importDcl\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"main$ebnf$1$subexpression$2$ebnf$3\", \"symbols\": [\"definition\"]},\n    {\"name\": \"main$ebnf$1$subexpression$2$ebnf$3\", \"symbols\": [\"main$ebnf$1$subexpression$2$ebnf$3\", \"definition\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"main$ebnf$1$subexpression$2\", \"symbols\": [\"main$ebnf$1$subexpression$2$ebnf$1\", \"main$ebnf$1$subexpression$2$ebnf$2\", \"main$ebnf$1$subexpression$2$ebnf$3\"]},\n    {\"name\": \"main$ebnf$1\", \"symbols\": [\"main$ebnf$1\", \"main$ebnf$1$subexpression$2\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"main\", \"symbols\": [\"main$ebnf$1\"], \"postprocess\":  d => {\n          return d[0].flatMap(inner => inner[2].flat());\n        }\n        },\n    {\"name\": \"header\", \"symbols\": [(lexer.has(\"HEADER\") ? {type: \"HEADER\"} : HEADER)], \"postprocess\": noop},\n    {\"name\": \"importDcl$subexpression$1\", \"symbols\": [(lexer.has(\"STRING\") ? {type: \"STRING\"} : STRING)]},\n    {\"name\": \"importDcl$subexpression$1$ebnf$1\", \"symbols\": []},\n    {\"name\": \"importDcl$subexpression$1$ebnf$1$subexpression$1\", \"symbols\": [{\"literal\":\"/\"}, (lexer.has(\"NAME\") ? {type: \"NAME\"} : NAME)]},\n    {\"name\": \"importDcl$subexpression$1$ebnf$1\", \"symbols\": [\"importDcl$subexpression$1$ebnf$1\", \"importDcl$subexpression$1$ebnf$1$subexpression$1\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"importDcl$subexpression$1\", \"symbols\": [{\"literal\":\"<\"}, (lexer.has(\"NAME\") ? {type: \"NAME\"} : NAME), \"importDcl$subexpression$1$ebnf$1\", {\"literal\":\".\"}, {\"literal\":\"idl\"}, {\"literal\":\">\"}]},\n    {\"name\": \"importDcl\", \"symbols\": [{\"literal\":\"#\"}, {\"literal\":\"include\"}, \"importDcl$subexpression$1\"], \"postprocess\": noop},\n    {\"name\": \"moduleDcl$ebnf$1$subexpression$1\", \"symbols\": [\"definition\"]},\n    {\"name\": \"moduleDcl$ebnf$1\", \"symbols\": [\"moduleDcl$ebnf$1$subexpression$1\"]},\n    {\"name\": \"moduleDcl$ebnf$1$subexpression$2\", \"symbols\": [\"definition\"]},\n    {\"name\": \"moduleDcl$ebnf$1\", \"symbols\": [\"moduleDcl$ebnf$1\", \"moduleDcl$ebnf$1$subexpression$2\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"moduleDcl\", \"symbols\": [\"multiAnnotations\", {\"literal\":\"module\"}, \"fieldName\", {\"literal\":\"{\"}, \"moduleDcl$ebnf$1\", {\"literal\":\"}\"}], \"postprocess\":  \n        function processModule(d) {\n          const moduleName = d[2].name;\n          const defs = d[4];\n          // need to return array here to keep same signature as processComplexModule\n          return {\n            definitionType: \"module\",\n            name: moduleName,\n            definitions: defs.flat(1),\n          };\n        }\n        },\n    {\"name\": \"definition$subexpression$1\", \"symbols\": [\"typeDcl\"]},\n    {\"name\": \"definition$subexpression$1\", \"symbols\": [\"constantDcl\"]},\n    {\"name\": \"definition$subexpression$1\", \"symbols\": [\"moduleDcl\"]},\n    {\"name\": \"definition\", \"symbols\": [\"definition$subexpression$1\", \"semi\"], \"postprocess\": d => d[0][0]},\n    {\"name\": \"typeDcl$subexpression$1\", \"symbols\": [\"structWithAnnotations\"]},\n    {\"name\": \"typeDcl$subexpression$1\", \"symbols\": [\"typedefWithAnnotations\"]},\n    {\"name\": \"typeDcl\", \"symbols\": [\"typeDcl$subexpression$1\"], \"postprocess\": d => d[0][0]},\n    {\"name\": \"structWithAnnotations\", \"symbols\": [\"multiAnnotations\", \"struct\"], \"postprocess\": \n        // default values don't apply to structs so we can just ignore all annotations on structs\n        d => d[1]\n        },\n    {\"name\": \"struct$ebnf$1$subexpression$1\", \"symbols\": [\"member\"]},\n    {\"name\": \"struct$ebnf$1\", \"symbols\": [\"struct$ebnf$1$subexpression$1\"]},\n    {\"name\": \"struct$ebnf$1$subexpression$2\", \"symbols\": [\"member\"]},\n    {\"name\": \"struct$ebnf$1\", \"symbols\": [\"struct$ebnf$1\", \"struct$ebnf$1$subexpression$2\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"struct\", \"symbols\": [{\"literal\":\"struct\"}, \"fieldName\", {\"literal\":\"{\"}, \"struct$ebnf$1\", {\"literal\":\"}\"}], \"postprocess\":  d => {\n          const name = d[1].name;\n          const definitions = d[3].flat(2).filter(def => def !== null);\n          return {\n            definitionType: 'struct',\n            name,\n            definitions,\n          };\n        } },\n    {\"name\": \"typedefWithAnnotations$subexpression$1\", \"symbols\": [\"typedef\", \"allTypes\", \"fieldName\", \"arrayLength\"]},\n    {\"name\": \"typedefWithAnnotations$subexpression$1\", \"symbols\": [\"typedef\", \"allTypes\", \"fieldName\"]},\n    {\"name\": \"typedefWithAnnotations$subexpression$1\", \"symbols\": [\"typedef\", \"sequenceType\", \"fieldName\"]},\n    {\"name\": \"typedefWithAnnotations\", \"symbols\": [\"multiAnnotations\", \"typedefWithAnnotations$subexpression$1\"], \"postprocess\":  d => {\n          const def = aggregateConstantUsage(extend(d.flat(1)));\n          return {\n            definitionType: \"typedef\",\n            ...def,\n          };\n        } },\n    {\"name\": \"typedef\", \"symbols\": [{\"literal\":\"typedef\"}], \"postprocess\": noop},\n    {\"name\": \"constantDcl\", \"symbols\": [\"multiAnnotations\", \"constType\"], \"postprocess\": d => d[1]},\n    {\"name\": \"member\", \"symbols\": [\"fieldWithAnnotation\", \"semi\"], \"postprocess\": d => d[0]},\n    {\"name\": \"fieldWithAnnotation\", \"symbols\": [\"multiAnnotations\", \"fieldDcl\"], \"postprocess\":  d=> {\n          let possibleAnnotations = [];\n          if(d[0]) {\n            possibleAnnotations = d[0];\n          }\n          const fields = d[1];\n          const finalDefs = fields.map((def) => \n            aggregateConstantUsage(extend([...possibleAnnotations, def]))\n          );\n          return finalDefs;\n        } },\n    {\"name\": \"fieldDcl$subexpression$1\", \"symbols\": [\"allTypes\", \"multiFieldNames\", \"arrayLength\"]},\n    {\"name\": \"fieldDcl$subexpression$1\", \"symbols\": [\"allTypes\", \"multiFieldNames\"]},\n    {\"name\": \"fieldDcl$subexpression$1\", \"symbols\": [\"sequenceType\", \"multiFieldNames\"]},\n    {\"name\": \"fieldDcl\", \"symbols\": [\"fieldDcl$subexpression$1\"], \"postprocess\":  (d) => {\n          const names = d[0].splice(1, 1)[0];\n          // create a definition for each name\n          const defs = names.map((nameObj) => extend([...d[0], nameObj]));\n          return defs;\n        } },\n    {\"name\": \"multiFieldNames$ebnf$1\", \"symbols\": []},\n    {\"name\": \"multiFieldNames$ebnf$1$subexpression$1\", \"symbols\": [{\"literal\":\",\"}, \"fieldName\"]},\n    {\"name\": \"multiFieldNames$ebnf$1\", \"symbols\": [\"multiFieldNames$ebnf$1\", \"multiFieldNames$ebnf$1$subexpression$1\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"multiFieldNames\", \"symbols\": [\"fieldName\", \"multiFieldNames$ebnf$1\"], \"postprocess\": \n        d => {\n          const fieldNames = d.flat(2).filter( d => d !== null && d.name);\n          return fieldNames;\n        } },\n    {\"name\": \"multiAnnotations$ebnf$1\", \"symbols\": []},\n    {\"name\": \"multiAnnotations$ebnf$1\", \"symbols\": [\"multiAnnotations$ebnf$1\", \"annotation\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"multiAnnotations\", \"symbols\": [\"multiAnnotations$ebnf$1\"], \"postprocess\": \n        d => {\n          return d[0] ? d[0].filter(d => d !== null) : null;\n        }\n        },\n    {\"name\": \"annotation$ebnf$1$subexpression$1\", \"symbols\": [{\"literal\":\"(\"}, \"multiAnnotationParams\", {\"literal\":\")\"}]},\n    {\"name\": \"annotation$ebnf$1\", \"symbols\": [\"annotation$ebnf$1$subexpression$1\"], \"postprocess\": id},\n    {\"name\": \"annotation$ebnf$1\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"annotation\", \"symbols\": [\"at\", (lexer.has(\"NAME\") ? {type: \"NAME\"} : NAME), \"annotation$ebnf$1\"], \"postprocess\":  d => {\n          const paramsMap = d[2] ? d[2][1] : {};\n          if(d[1].value === \"default\") {\n            const defaultValue = paramsMap.value;\n            return {defaultValue};\n          }\n          return null\n        } },\n    {\"name\": \"multiAnnotationParams$ebnf$1\", \"symbols\": []},\n    {\"name\": \"multiAnnotationParams$ebnf$1$subexpression$1\", \"symbols\": [{\"literal\":\",\"}, \"annotationParam\"]},\n    {\"name\": \"multiAnnotationParams$ebnf$1\", \"symbols\": [\"multiAnnotationParams$ebnf$1\", \"multiAnnotationParams$ebnf$1$subexpression$1\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"multiAnnotationParams\", \"symbols\": [\"annotationParam\", \"multiAnnotationParams$ebnf$1\"], \"postprocess\": \n        d => extend([d[0], ...d[1].flatMap(([, param]) => param)])\n        },\n    {\"name\": \"annotationParam$subexpression$1\", \"symbols\": [(lexer.has(\"NAME\") ? {type: \"NAME\"} : NAME), \"assignment\"]},\n    {\"name\": \"annotationParam\", \"symbols\": [\"annotationParam$subexpression$1\"], \"postprocess\": d => ({[d[0][0].value]: d[0][1].value})},\n    {\"name\": \"annotationParam$subexpression$2\", \"symbols\": [(lexer.has(\"NAME\") ? {type: \"NAME\"} : NAME)]},\n    {\"name\": \"annotationParam\", \"symbols\": [\"annotationParam$subexpression$2\"], \"postprocess\": noop},\n    {\"name\": \"at\", \"symbols\": [{\"literal\":\"@\"}], \"postprocess\": noop},\n    {\"name\": \"constType$subexpression$1\", \"symbols\": [\"constKeyword\", \"numericType\", \"fieldName\", \"floatAssignment\", \"simple\"]},\n    {\"name\": \"constType$subexpression$1\", \"symbols\": [\"constKeyword\", \"numericType\", \"fieldName\", \"intAssignment\", \"simple\"]},\n    {\"name\": \"constType$subexpression$1\", \"symbols\": [\"constKeyword\", \"stringType\", \"fieldName\", \"stringAssignment\", \"simple\"]},\n    {\"name\": \"constType$subexpression$1\", \"symbols\": [\"constKeyword\", \"booleanType\", \"fieldName\", \"booleanAssignment\", \"simple\"]},\n    {\"name\": \"constType\", \"symbols\": [\"constType$subexpression$1\"], \"postprocess\":  d => {\n          const def = extend(d[0]);\n          const name = def.name;\n          const value = def.value;\n          return def;\n        } },\n    {\"name\": \"constKeyword\", \"symbols\": [{\"literal\":\"const\"}], \"postprocess\": d => ({isConstant: true})},\n    {\"name\": \"fieldName\", \"symbols\": [(lexer.has(\"NAME\") ? {type: \"NAME\"} : NAME)], \"postprocess\": d => ({name: d[0].value})},\n    {\"name\": \"sequenceType$ebnf$1$subexpression$1$subexpression$1\", \"symbols\": [\"INT\"]},\n    {\"name\": \"sequenceType$ebnf$1$subexpression$1$subexpression$1\", \"symbols\": [(lexer.has(\"NAME\") ? {type: \"NAME\"} : NAME)]},\n    {\"name\": \"sequenceType$ebnf$1$subexpression$1\", \"symbols\": [{\"literal\":\",\"}, \"sequenceType$ebnf$1$subexpression$1$subexpression$1\"]},\n    {\"name\": \"sequenceType$ebnf$1\", \"symbols\": [\"sequenceType$ebnf$1$subexpression$1\"], \"postprocess\": id},\n    {\"name\": \"sequenceType$ebnf$1\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"sequenceType\", \"symbols\": [{\"literal\":\"sequence\"}, {\"literal\":\"<\"}, \"allTypes\", \"sequenceType$ebnf$1\", {\"literal\":\">\"}], \"postprocess\":  d => {\n          const arrayUpperBound = d[3] !== null ? getIntOrConstantValue(d[3][1][0]) : undefined;\n          const typeObj = d[2];\n          return {\n            ...typeObj,\n            isArray: true, \n            arrayUpperBound,\n          };\n        }},\n    {\"name\": \"arrayLength$subexpression$1\", \"symbols\": [\"INT\"]},\n    {\"name\": \"arrayLength$subexpression$1\", \"symbols\": [(lexer.has(\"NAME\") ? {type: \"NAME\"} : NAME)]},\n    {\"name\": \"arrayLength\", \"symbols\": [{\"literal\":\"[\"}, \"arrayLength$subexpression$1\", {\"literal\":\"]\"}], \"postprocess\": \n        ([, intOrName]) => ({isArray: true, arrayLength: getIntOrConstantValue(intOrName ? intOrName[0] : undefined) }) \n        },\n    {\"name\": \"assignment$subexpression$1\", \"symbols\": [\"floatAssignment\"]},\n    {\"name\": \"assignment$subexpression$1\", \"symbols\": [\"intAssignment\"]},\n    {\"name\": \"assignment$subexpression$1\", \"symbols\": [\"stringAssignment\"]},\n    {\"name\": \"assignment$subexpression$1\", \"symbols\": [\"booleanAssignment\"]},\n    {\"name\": \"assignment$subexpression$1\", \"symbols\": [\"variableAssignment\"]},\n    {\"name\": \"assignment\", \"symbols\": [\"assignment$subexpression$1\"], \"postprocess\": d => d[0][0]},\n    {\"name\": \"floatAssignment$subexpression$1\", \"symbols\": [\"SIGNED_FLOAT\"]},\n    {\"name\": \"floatAssignment$subexpression$1\", \"symbols\": [\"FLOAT\"]},\n    {\"name\": \"floatAssignment\", \"symbols\": [(lexer.has(\"EQ\") ? {type: \"EQ\"} : EQ), \"floatAssignment$subexpression$1\"], \"postprocess\": ([, num]) => ({valueText: num[0], value: parseFloat(num[0])})},\n    {\"name\": \"intAssignment$subexpression$1\", \"symbols\": [\"SIGNED_INT\"]},\n    {\"name\": \"intAssignment$subexpression$1\", \"symbols\": [\"INT\"]},\n    {\"name\": \"intAssignment\", \"symbols\": [(lexer.has(\"EQ\") ? {type: \"EQ\"} : EQ), \"intAssignment$subexpression$1\"], \"postprocess\": ([, num]) => ({valueText: num[0], value: parseInt(num[0])})},\n    {\"name\": \"stringAssignment\", \"symbols\": [(lexer.has(\"EQ\") ? {type: \"EQ\"} : EQ), \"STR\"], \"postprocess\": ([, str]) => ({valueText: str, value: str})},\n    {\"name\": \"booleanAssignment\", \"symbols\": [(lexer.has(\"EQ\") ? {type: \"EQ\"} : EQ), \"BOOLEAN\"], \"postprocess\": ([, bool]) => ({valueText: bool, value: bool === \"TRUE\"})},\n    {\"name\": \"variableAssignment\", \"symbols\": [(lexer.has(\"EQ\") ? {type: \"EQ\"} : EQ), (lexer.has(\"NAME\") ? {type: \"NAME\"} : NAME)], \"postprocess\": ([, name]) => ({valueText: name.value, value: {usesConstant: true, name: name.value}})},\n    {\"name\": \"allTypes$subexpression$1\", \"symbols\": [\"primitiveTypes\"]},\n    {\"name\": \"allTypes$subexpression$1\", \"symbols\": [\"customType\"]},\n    {\"name\": \"allTypes\", \"symbols\": [\"allTypes$subexpression$1\"], \"postprocess\": d => d[0][0]},\n    {\"name\": \"primitiveTypes$subexpression$1\", \"symbols\": [\"stringType\"]},\n    {\"name\": \"primitiveTypes$subexpression$1\", \"symbols\": [\"numericType\"]},\n    {\"name\": \"primitiveTypes$subexpression$1\", \"symbols\": [\"booleanType\"]},\n    {\"name\": \"primitiveTypes\", \"symbols\": [\"primitiveTypes$subexpression$1\"], \"postprocess\": d => ({...d[0][0], isComplex: false})},\n    {\"name\": \"customType\", \"symbols\": [(lexer.has(\"NAME\") ? {type: \"NAME\"} : NAME)], \"postprocess\":  d => {\n          const typeName = d[0].value;\n          // won't be replaced later with a typedef alias definition\n          // typedefs can't include :: in their name, but they can be complex\n          const isDefinitelyComplex = typeName.includes(\"::\");\n          \n          // post process will go through and replace typedefs with their actual type\n          return {type: typeName, isComplex: isDefinitelyComplex };\n        }},\n    {\"name\": \"stringType$subexpression$1\", \"symbols\": [{\"literal\":\"string\"}]},\n    {\"name\": \"stringType$subexpression$1\", \"symbols\": [{\"literal\":\"wstring\"}]},\n    {\"name\": \"stringType$ebnf$1$subexpression$1$subexpression$1\", \"symbols\": [\"INT\"]},\n    {\"name\": \"stringType$ebnf$1$subexpression$1$subexpression$1\", \"symbols\": [(lexer.has(\"NAME\") ? {type: \"NAME\"} : NAME)]},\n    {\"name\": \"stringType$ebnf$1$subexpression$1\", \"symbols\": [{\"literal\":\"<\"}, \"stringType$ebnf$1$subexpression$1$subexpression$1\", {\"literal\":\">\"}]},\n    {\"name\": \"stringType$ebnf$1\", \"symbols\": [\"stringType$ebnf$1$subexpression$1\"], \"postprocess\": id},\n    {\"name\": \"stringType$ebnf$1\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"stringType\", \"symbols\": [\"stringType$subexpression$1\", \"stringType$ebnf$1\"], \"postprocess\":  d => {\n          let strLength = undefined;\n          if(d[1] !== null) {\n            strLength = getIntOrConstantValue(d[1][1] ? d[1][1][0] : undefined);\n          }\n          return {type: \"string\", upperBound: strLength};\n        } },\n    {\"name\": \"booleanType\", \"symbols\": [{\"literal\":\"boolean\"}], \"postprocess\": d => ({type: \"bool\"})},\n    {\"name\": \"numericType$subexpression$1\", \"symbols\": [{\"literal\":\"byte\"}]},\n    {\"name\": \"numericType$subexpression$1\", \"symbols\": [{\"literal\":\"octet\"}]},\n    {\"name\": \"numericType$subexpression$1\", \"symbols\": [{\"literal\":\"wchar\"}]},\n    {\"name\": \"numericType$subexpression$1\", \"symbols\": [{\"literal\":\"char\"}]},\n    {\"name\": \"numericType$subexpression$1\", \"symbols\": [{\"literal\":\"long\"}, {\"literal\":\"double\"}]},\n    {\"name\": \"numericType$subexpression$1\", \"symbols\": [{\"literal\":\"double\"}]},\n    {\"name\": \"numericType$subexpression$1\", \"symbols\": [{\"literal\":\"float\"}]},\n    {\"name\": \"numericType$subexpression$1\", \"symbols\": [{\"literal\":\"int8\"}]},\n    {\"name\": \"numericType$subexpression$1\", \"symbols\": [{\"literal\":\"uint8\"}]},\n    {\"name\": \"numericType$subexpression$1\", \"symbols\": [{\"literal\":\"int16\"}]},\n    {\"name\": \"numericType$subexpression$1\", \"symbols\": [{\"literal\":\"uint16\"}]},\n    {\"name\": \"numericType$subexpression$1\", \"symbols\": [{\"literal\":\"int32\"}]},\n    {\"name\": \"numericType$subexpression$1\", \"symbols\": [{\"literal\":\"uint32\"}]},\n    {\"name\": \"numericType$subexpression$1\", \"symbols\": [{\"literal\":\"int64\"}]},\n    {\"name\": \"numericType$subexpression$1\", \"symbols\": [{\"literal\":\"uint64\"}]},\n    {\"name\": \"numericType$subexpression$1\", \"symbols\": [{\"literal\":\"unsigned\"}, {\"literal\":\"short\"}]},\n    {\"name\": \"numericType$subexpression$1\", \"symbols\": [{\"literal\":\"short\"}]},\n    {\"name\": \"numericType$subexpression$1\", \"symbols\": [{\"literal\":\"unsigned\"}, {\"literal\":\"long\"}, {\"literal\":\"long\"}]},\n    {\"name\": \"numericType$subexpression$1\", \"symbols\": [{\"literal\":\"long\"}, {\"literal\":\"long\"}]},\n    {\"name\": \"numericType$subexpression$1\", \"symbols\": [{\"literal\":\"unsigned\"}, {\"literal\":\"long\"}]},\n    {\"name\": \"numericType$subexpression$1\", \"symbols\": [{\"literal\":\"long\"}]},\n    {\"name\": \"numericType\", \"symbols\": [\"numericType$subexpression$1\"], \"postprocess\":  (d) => { \n          const typeString = d[0].map((t) => t?.value).filter(t => !!t).join(\" \");\n          let type = numericTypeMap[typeString];\n          return { type: type ? type : typeString };\n        }\n        },\n    {\"name\": \"BOOLEAN$subexpression$1\", \"symbols\": [{\"literal\":\"TRUE\"}]},\n    {\"name\": \"BOOLEAN$subexpression$1\", \"symbols\": [{\"literal\":\"FALSE\"}]},\n    {\"name\": \"BOOLEAN\", \"symbols\": [\"BOOLEAN$subexpression$1\"], \"postprocess\": join},\n    {\"name\": \"STR$ebnf$1\", \"symbols\": [(lexer.has(\"STRING\") ? {type: \"STRING\"} : STRING)]},\n    {\"name\": \"STR$ebnf$1\", \"symbols\": [\"STR$ebnf$1\", (lexer.has(\"STRING\") ? {type: \"STRING\"} : STRING)], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"STR\", \"symbols\": [\"STR$ebnf$1\"], \"postprocess\":  d => {\n          return join(d.flat(1).filter(d => d !== null));\n        }},\n    {\"name\": \"SIGNED_FLOAT$subexpression$1\", \"symbols\": [{\"literal\":\"+\"}]},\n    {\"name\": \"SIGNED_FLOAT$subexpression$1\", \"symbols\": [{\"literal\":\"-\"}]},\n    {\"name\": \"SIGNED_FLOAT\", \"symbols\": [\"SIGNED_FLOAT$subexpression$1\", \"FLOAT\"], \"postprocess\": join},\n    {\"name\": \"FLOAT$subexpression$1\", \"symbols\": [(lexer.has(\"DECIMAL\") ? {type: \"DECIMAL\"} : DECIMAL)]},\n    {\"name\": \"FLOAT$subexpression$1\", \"symbols\": [(lexer.has(\"DECIMALEXP\") ? {type: \"DECIMALEXP\"} : DECIMALEXP)]},\n    {\"name\": \"FLOAT\", \"symbols\": [\"FLOAT$subexpression$1\"], \"postprocess\": join},\n    {\"name\": \"FLOAT$subexpression$2\", \"symbols\": [(lexer.has(\"DECIMAL\") ? {type: \"DECIMAL\"} : DECIMAL), {\"literal\":\"d\"}]},\n    {\"name\": \"FLOAT\", \"symbols\": [\"FLOAT$subexpression$2\"], \"postprocess\": d => d[0][0].value},\n    {\"name\": \"FLOAT$subexpression$3\", \"symbols\": [\"INT\", {\"literal\":\"d\"}]},\n    {\"name\": \"FLOAT\", \"symbols\": [\"FLOAT$subexpression$3\"], \"postprocess\": d => d[0][0]},\n    {\"name\": \"SIGNED_INT$subexpression$1\", \"symbols\": [{\"literal\":\"+\"}]},\n    {\"name\": \"SIGNED_INT$subexpression$1\", \"symbols\": [{\"literal\":\"-\"}]},\n    {\"name\": \"SIGNED_INT\", \"symbols\": [\"SIGNED_INT$subexpression$1\", \"INT\"], \"postprocess\": join},\n    {\"name\": \"INT\", \"symbols\": [(lexer.has(\"INTEGER\") ? {type: \"INTEGER\"} : INTEGER)], \"postprocess\": join},\n    {\"name\": \"semi\", \"symbols\": [{\"literal\":\";\"}], \"postprocess\": noop},\n    {\"name\": \"simple\", \"symbols\": [], \"postprocess\": () => ({isComplex: false})}\n]\n  , ParserStart: \"main\"\n}\nif (typeof module !== 'undefined'&& typeof module.exports !== 'undefined') {\n   module.exports = grammar;\n} else {\n   window.grammar = grammar;\n}\n})();\n","(function(root, factory) {\n    if (typeof module === 'object' && module.exports) {\n        module.exports = factory();\n    } else {\n        root.nearley = factory();\n    }\n}(this, function() {\n\n    function Rule(name, symbols, postprocess) {\n        this.id = ++Rule.highestId;\n        this.name = name;\n        this.symbols = symbols;        // a list of literal | regex class | nonterminal\n        this.postprocess = postprocess;\n        return this;\n    }\n    Rule.highestId = 0;\n\n    Rule.prototype.toString = function(withCursorAt) {\n        var symbolSequence = (typeof withCursorAt === \"undefined\")\n                             ? this.symbols.map(getSymbolShortDisplay).join(' ')\n                             : (   this.symbols.slice(0, withCursorAt).map(getSymbolShortDisplay).join(' ')\n                                 + \" ● \"\n                                 + this.symbols.slice(withCursorAt).map(getSymbolShortDisplay).join(' ')     );\n        return this.name + \" → \" + symbolSequence;\n    }\n\n\n    // a State is a rule at a position from a given starting point in the input stream (reference)\n    function State(rule, dot, reference, wantedBy) {\n        this.rule = rule;\n        this.dot = dot;\n        this.reference = reference;\n        this.data = [];\n        this.wantedBy = wantedBy;\n        this.isComplete = this.dot === rule.symbols.length;\n    }\n\n    State.prototype.toString = function() {\n        return \"{\" + this.rule.toString(this.dot) + \"}, from: \" + (this.reference || 0);\n    };\n\n    State.prototype.nextState = function(child) {\n        var state = new State(this.rule, this.dot + 1, this.reference, this.wantedBy);\n        state.left = this;\n        state.right = child;\n        if (state.isComplete) {\n            state.data = state.build();\n            // Having right set here will prevent the right state and its children\n            // form being garbage collected\n            state.right = undefined;\n        }\n        return state;\n    };\n\n    State.prototype.build = function() {\n        var children = [];\n        var node = this;\n        do {\n            children.push(node.right.data);\n            node = node.left;\n        } while (node.left);\n        children.reverse();\n        return children;\n    };\n\n    State.prototype.finish = function() {\n        if (this.rule.postprocess) {\n            this.data = this.rule.postprocess(this.data, this.reference, Parser.fail);\n        }\n    };\n\n\n    function Column(grammar, index) {\n        this.grammar = grammar;\n        this.index = index;\n        this.states = [];\n        this.wants = {}; // states indexed by the non-terminal they expect\n        this.scannable = []; // list of states that expect a token\n        this.completed = {}; // states that are nullable\n    }\n\n\n    Column.prototype.process = function(nextColumn) {\n        var states = this.states;\n        var wants = this.wants;\n        var completed = this.completed;\n\n        for (var w = 0; w < states.length; w++) { // nb. we push() during iteration\n            var state = states[w];\n\n            if (state.isComplete) {\n                state.finish();\n                if (state.data !== Parser.fail) {\n                    // complete\n                    var wantedBy = state.wantedBy;\n                    for (var i = wantedBy.length; i--; ) { // this line is hot\n                        var left = wantedBy[i];\n                        this.complete(left, state);\n                    }\n\n                    // special-case nullables\n                    if (state.reference === this.index) {\n                        // make sure future predictors of this rule get completed.\n                        var exp = state.rule.name;\n                        (this.completed[exp] = this.completed[exp] || []).push(state);\n                    }\n                }\n\n            } else {\n                // queue scannable states\n                var exp = state.rule.symbols[state.dot];\n                if (typeof exp !== 'string') {\n                    this.scannable.push(state);\n                    continue;\n                }\n\n                // predict\n                if (wants[exp]) {\n                    wants[exp].push(state);\n\n                    if (completed.hasOwnProperty(exp)) {\n                        var nulls = completed[exp];\n                        for (var i = 0; i < nulls.length; i++) {\n                            var right = nulls[i];\n                            this.complete(state, right);\n                        }\n                    }\n                } else {\n                    wants[exp] = [state];\n                    this.predict(exp);\n                }\n            }\n        }\n    }\n\n    Column.prototype.predict = function(exp) {\n        var rules = this.grammar.byName[exp] || [];\n\n        for (var i = 0; i < rules.length; i++) {\n            var r = rules[i];\n            var wantedBy = this.wants[exp];\n            var s = new State(r, 0, this.index, wantedBy);\n            this.states.push(s);\n        }\n    }\n\n    Column.prototype.complete = function(left, right) {\n        var copy = left.nextState(right);\n        this.states.push(copy);\n    }\n\n\n    function Grammar(rules, start) {\n        this.rules = rules;\n        this.start = start || this.rules[0].name;\n        var byName = this.byName = {};\n        this.rules.forEach(function(rule) {\n            if (!byName.hasOwnProperty(rule.name)) {\n                byName[rule.name] = [];\n            }\n            byName[rule.name].push(rule);\n        });\n    }\n\n    // So we can allow passing (rules, start) directly to Parser for backwards compatibility\n    Grammar.fromCompiled = function(rules, start) {\n        var lexer = rules.Lexer;\n        if (rules.ParserStart) {\n          start = rules.ParserStart;\n          rules = rules.ParserRules;\n        }\n        var rules = rules.map(function (r) { return (new Rule(r.name, r.symbols, r.postprocess)); });\n        var g = new Grammar(rules, start);\n        g.lexer = lexer; // nb. storing lexer on Grammar is iffy, but unavoidable\n        return g;\n    }\n\n\n    function StreamLexer() {\n      this.reset(\"\");\n    }\n\n    StreamLexer.prototype.reset = function(data, state) {\n        this.buffer = data;\n        this.index = 0;\n        this.line = state ? state.line : 1;\n        this.lastLineBreak = state ? -state.col : 0;\n    }\n\n    StreamLexer.prototype.next = function() {\n        if (this.index < this.buffer.length) {\n            var ch = this.buffer[this.index++];\n            if (ch === '\\n') {\n              this.line += 1;\n              this.lastLineBreak = this.index;\n            }\n            return {value: ch};\n        }\n    }\n\n    StreamLexer.prototype.save = function() {\n      return {\n        line: this.line,\n        col: this.index - this.lastLineBreak,\n      }\n    }\n\n    StreamLexer.prototype.formatError = function(token, message) {\n        // nb. this gets called after consuming the offending token,\n        // so the culprit is index-1\n        var buffer = this.buffer;\n        if (typeof buffer === 'string') {\n            var lines = buffer\n                .split(\"\\n\")\n                .slice(\n                    Math.max(0, this.line - 5), \n                    this.line\n                );\n\n            var nextLineBreak = buffer.indexOf('\\n', this.index);\n            if (nextLineBreak === -1) nextLineBreak = buffer.length;\n            var col = this.index - this.lastLineBreak;\n            var lastLineDigits = String(this.line).length;\n            message += \" at line \" + this.line + \" col \" + col + \":\\n\\n\";\n            message += lines\n                .map(function(line, i) {\n                    return pad(this.line - lines.length + i + 1, lastLineDigits) + \" \" + line;\n                }, this)\n                .join(\"\\n\");\n            message += \"\\n\" + pad(\"\", lastLineDigits + col) + \"^\\n\";\n            return message;\n        } else {\n            return message + \" at index \" + (this.index - 1);\n        }\n\n        function pad(n, length) {\n            var s = String(n);\n            return Array(length - s.length + 1).join(\" \") + s;\n        }\n    }\n\n    function Parser(rules, start, options) {\n        if (rules instanceof Grammar) {\n            var grammar = rules;\n            var options = start;\n        } else {\n            var grammar = Grammar.fromCompiled(rules, start);\n        }\n        this.grammar = grammar;\n\n        // Read options\n        this.options = {\n            keepHistory: false,\n            lexer: grammar.lexer || new StreamLexer,\n        };\n        for (var key in (options || {})) {\n            this.options[key] = options[key];\n        }\n\n        // Setup lexer\n        this.lexer = this.options.lexer;\n        this.lexerState = undefined;\n\n        // Setup a table\n        var column = new Column(grammar, 0);\n        var table = this.table = [column];\n\n        // I could be expecting anything.\n        column.wants[grammar.start] = [];\n        column.predict(grammar.start);\n        // TODO what if start rule is nullable?\n        column.process();\n        this.current = 0; // token index\n    }\n\n    // create a reserved token for indicating a parse fail\n    Parser.fail = {};\n\n    Parser.prototype.feed = function(chunk) {\n        var lexer = this.lexer;\n        lexer.reset(chunk, this.lexerState);\n\n        var token;\n        while (true) {\n            try {\n                token = lexer.next();\n                if (!token) {\n                    break;\n                }\n            } catch (e) {\n                // Create the next column so that the error reporter\n                // can display the correctly predicted states.\n                var nextColumn = new Column(this.grammar, this.current + 1);\n                this.table.push(nextColumn);\n                var err = new Error(this.reportLexerError(e));\n                err.offset = this.current;\n                err.token = e.token;\n                throw err;\n            }\n            // We add new states to table[current+1]\n            var column = this.table[this.current];\n\n            // GC unused states\n            if (!this.options.keepHistory) {\n                delete this.table[this.current - 1];\n            }\n\n            var n = this.current + 1;\n            var nextColumn = new Column(this.grammar, n);\n            this.table.push(nextColumn);\n\n            // Advance all tokens that expect the symbol\n            var literal = token.text !== undefined ? token.text : token.value;\n            var value = lexer.constructor === StreamLexer ? token.value : token;\n            var scannable = column.scannable;\n            for (var w = scannable.length; w--; ) {\n                var state = scannable[w];\n                var expect = state.rule.symbols[state.dot];\n                // Try to consume the token\n                // either regex or literal\n                if (expect.test ? expect.test(value) :\n                    expect.type ? expect.type === token.type\n                                : expect.literal === literal) {\n                    // Add it\n                    var next = state.nextState({data: value, token: token, isToken: true, reference: n - 1});\n                    nextColumn.states.push(next);\n                }\n            }\n\n            // Next, for each of the rules, we either\n            // (a) complete it, and try to see if the reference row expected that\n            //     rule\n            // (b) predict the next nonterminal it expects by adding that\n            //     nonterminal's start state\n            // To prevent duplication, we also keep track of rules we have already\n            // added\n\n            nextColumn.process();\n\n            // If needed, throw an error:\n            if (nextColumn.states.length === 0) {\n                // No states at all! This is not good.\n                var err = new Error(this.reportError(token));\n                err.offset = this.current;\n                err.token = token;\n                throw err;\n            }\n\n            // maybe save lexer state\n            if (this.options.keepHistory) {\n              column.lexerState = lexer.save()\n            }\n\n            this.current++;\n        }\n        if (column) {\n          this.lexerState = lexer.save()\n        }\n\n        // Incrementally keep track of results\n        this.results = this.finish();\n\n        // Allow chaining, for whatever it's worth\n        return this;\n    };\n\n    Parser.prototype.reportLexerError = function(lexerError) {\n        var tokenDisplay, lexerMessage;\n        // Planning to add a token property to moo's thrown error\n        // even on erroring tokens to be used in error display below\n        var token = lexerError.token;\n        if (token) {\n            tokenDisplay = \"input \" + JSON.stringify(token.text[0]) + \" (lexer error)\";\n            lexerMessage = this.lexer.formatError(token, \"Syntax error\");\n        } else {\n            tokenDisplay = \"input (lexer error)\";\n            lexerMessage = lexerError.message;\n        }\n        return this.reportErrorCommon(lexerMessage, tokenDisplay);\n    };\n\n    Parser.prototype.reportError = function(token) {\n        var tokenDisplay = (token.type ? token.type + \" token: \" : \"\") + JSON.stringify(token.value !== undefined ? token.value : token);\n        var lexerMessage = this.lexer.formatError(token, \"Syntax error\");\n        return this.reportErrorCommon(lexerMessage, tokenDisplay);\n    };\n\n    Parser.prototype.reportErrorCommon = function(lexerMessage, tokenDisplay) {\n        var lines = [];\n        lines.push(lexerMessage);\n        var lastColumnIndex = this.table.length - 2;\n        var lastColumn = this.table[lastColumnIndex];\n        var expectantStates = lastColumn.states\n            .filter(function(state) {\n                var nextSymbol = state.rule.symbols[state.dot];\n                return nextSymbol && typeof nextSymbol !== \"string\";\n            });\n\n        if (expectantStates.length === 0) {\n            lines.push('Unexpected ' + tokenDisplay + '. I did not expect any more input. Here is the state of my parse table:\\n');\n            this.displayStateStack(lastColumn.states, lines);\n        } else {\n            lines.push('Unexpected ' + tokenDisplay + '. Instead, I was expecting to see one of the following:\\n');\n            // Display a \"state stack\" for each expectant state\n            // - which shows you how this state came to be, step by step.\n            // If there is more than one derivation, we only display the first one.\n            var stateStacks = expectantStates\n                .map(function(state) {\n                    return this.buildFirstStateStack(state, []) || [state];\n                }, this);\n            // Display each state that is expecting a terminal symbol next.\n            stateStacks.forEach(function(stateStack) {\n                var state = stateStack[0];\n                var nextSymbol = state.rule.symbols[state.dot];\n                var symbolDisplay = this.getSymbolDisplay(nextSymbol);\n                lines.push('A ' + symbolDisplay + ' based on:');\n                this.displayStateStack(stateStack, lines);\n            }, this);\n        }\n        lines.push(\"\");\n        return lines.join(\"\\n\");\n    }\n    \n    Parser.prototype.displayStateStack = function(stateStack, lines) {\n        var lastDisplay;\n        var sameDisplayCount = 0;\n        for (var j = 0; j < stateStack.length; j++) {\n            var state = stateStack[j];\n            var display = state.rule.toString(state.dot);\n            if (display === lastDisplay) {\n                sameDisplayCount++;\n            } else {\n                if (sameDisplayCount > 0) {\n                    lines.push('    ^ ' + sameDisplayCount + ' more lines identical to this');\n                }\n                sameDisplayCount = 0;\n                lines.push('    ' + display);\n            }\n            lastDisplay = display;\n        }\n    };\n\n    Parser.prototype.getSymbolDisplay = function(symbol) {\n        return getSymbolLongDisplay(symbol);\n    };\n\n    /*\n    Builds a the first state stack. You can think of a state stack as the call stack\n    of the recursive-descent parser which the Nearley parse algorithm simulates.\n    A state stack is represented as an array of state objects. Within a\n    state stack, the first item of the array will be the starting\n    state, with each successive item in the array going further back into history.\n\n    This function needs to be given a starting state and an empty array representing\n    the visited states, and it returns an single state stack.\n\n    */\n    Parser.prototype.buildFirstStateStack = function(state, visited) {\n        if (visited.indexOf(state) !== -1) {\n            // Found cycle, return null\n            // to eliminate this path from the results, because\n            // we don't know how to display it meaningfully\n            return null;\n        }\n        if (state.wantedBy.length === 0) {\n            return [state];\n        }\n        var prevState = state.wantedBy[0];\n        var childVisited = [state].concat(visited);\n        var childResult = this.buildFirstStateStack(prevState, childVisited);\n        if (childResult === null) {\n            return null;\n        }\n        return [state].concat(childResult);\n    };\n\n    Parser.prototype.save = function() {\n        var column = this.table[this.current];\n        column.lexerState = this.lexerState;\n        return column;\n    };\n\n    Parser.prototype.restore = function(column) {\n        var index = column.index;\n        this.current = index;\n        this.table[index] = column;\n        this.table.splice(index + 1);\n        this.lexerState = column.lexerState;\n\n        // Incrementally keep track of results\n        this.results = this.finish();\n    };\n\n    // nb. deprecated: use save/restore instead!\n    Parser.prototype.rewind = function(index) {\n        if (!this.options.keepHistory) {\n            throw new Error('set option `keepHistory` to enable rewinding')\n        }\n        // nb. recall column (table) indicies fall between token indicies.\n        //        col 0   --   token 0   --   col 1\n        this.restore(this.table[index]);\n    };\n\n    Parser.prototype.finish = function() {\n        // Return the possible parsings\n        var considerations = [];\n        var start = this.grammar.start;\n        var column = this.table[this.table.length - 1]\n        column.states.forEach(function (t) {\n            if (t.rule.name === start\n                    && t.dot === t.rule.symbols.length\n                    && t.reference === 0\n                    && t.data !== Parser.fail) {\n                considerations.push(t);\n            }\n        });\n        return considerations.map(function(c) {return c.data; });\n    };\n\n    function getSymbolLongDisplay(symbol) {\n        var type = typeof symbol;\n        if (type === \"string\") {\n            return symbol;\n        } else if (type === \"object\") {\n            if (symbol.literal) {\n                return JSON.stringify(symbol.literal);\n            } else if (symbol instanceof RegExp) {\n                return 'character matching ' + symbol;\n            } else if (symbol.type) {\n                return symbol.type + ' token';\n            } else if (symbol.test) {\n                return 'token matching ' + String(symbol.test);\n            } else {\n                throw new Error('Unknown symbol type: ' + symbol);\n            }\n        }\n    }\n\n    function getSymbolShortDisplay(symbol) {\n        var type = typeof symbol;\n        if (type === \"string\") {\n            return symbol;\n        } else if (type === \"object\") {\n            if (symbol.literal) {\n                return JSON.stringify(symbol.literal);\n            } else if (symbol instanceof RegExp) {\n                return symbol.toString();\n            } else if (symbol.type) {\n                return '%' + symbol.type;\n            } else if (symbol.test) {\n                return '<' + String(symbol.test) + '>';\n            } else {\n                throw new Error('Unknown symbol type: ' + symbol);\n            }\n        }\n    }\n\n    return {\n        Parser: Parser,\n        Grammar: Grammar,\n        Rule: Rule,\n    };\n\n}));\n","import { MessageDefinition, MessageDefinitionField } from \"@foxglove/message-definition\";\n\n/**\n * Parser for ROS 2 type definition lines.\n * Reference implementation: https://github.com/ros2/rosidl/blob/master/rosidl_adapter/rosidl_adapter/parser.py\n */\n\nconst TYPE = String.raw`(?<type>[a-zA-Z0-9_/]+)`;\nconst STRING_BOUND = String.raw`(?:<=(?<stringBound>\\d+))`;\nconst ARRAY_BOUND = String.raw`(?:(?<unboundedArray>\\[\\])|\\[(?<arrayLength>\\d+)\\]|\\[<=(?<arrayBound>\\d+)\\])`;\nconst NAME = String.raw`(?<name>[a-zA-Z0-9_]+)`;\nconst QUOTED_STRING = String.raw`'(?:\\\\.|[^'\\\\])*'|\"(?:\\\\.|[^\"\\\\])*\"`;\nconst COMMENT_TERMINATED_LITERAL = String.raw`(?:${QUOTED_STRING}|(?:\\\\.|[^\\s'\"#\\\\])(?:\\\\.|[^#\\\\])*)`;\nconst ARRAY_TERMINATED_LITERAL = String.raw`(?:${QUOTED_STRING}|(?:\\\\.|[^\\s'\"\\],#\\\\])(?:\\\\.|[^\\],#\\\\])*)`;\nconst CONSTANT_ASSIGNMENT = String.raw`\\s*=\\s*(?<constantValue>${COMMENT_TERMINATED_LITERAL}?)`;\nconst DEFAULT_VALUE_ARRAY = String.raw`\\[(?:${ARRAY_TERMINATED_LITERAL},)*${ARRAY_TERMINATED_LITERAL}?\\]`;\nconst DEFAULT_VALUE = String.raw`(?<defaultValue>${DEFAULT_VALUE_ARRAY}|${COMMENT_TERMINATED_LITERAL})`;\nconst COMMENT = String.raw`(?:#.*)`;\nconst DEFINITION_LINE_REGEX = new RegExp(\n  String.raw`^${TYPE}${STRING_BOUND}?${ARRAY_BOUND}?\\s+${NAME}(?:${CONSTANT_ASSIGNMENT}|\\s+${DEFAULT_VALUE})?\\s*${COMMENT}?$`,\n);\n\nconst STRING_ESCAPES = String.raw`\\\\(?<char>['\"abfnrtv\\\\])|\\\\(?<oct>[0-7]{1,3})|\\\\x(?<hex2>[a-fA-F0-9]{2})|\\\\u(?<hex4>[a-fA-F0-9]{4})|\\\\U(?<hex8>[a-fA-F0-9]{8})`;\n\nconst BUILTIN_TYPES = [\n  \"bool\",\n  \"byte\",\n  \"char\",\n  \"float32\",\n  \"float64\",\n  \"int8\",\n  \"uint8\",\n  \"int16\",\n  \"uint16\",\n  \"int32\",\n  \"uint32\",\n  \"int64\",\n  \"uint64\",\n  \"string\",\n  \"wstring\",\n  \"time\",\n  \"duration\",\n  \"builtin_interfaces/Time\",\n  \"builtin_interfaces/Duration\",\n  \"builtin_interfaces/msg/Time\",\n  \"builtin_interfaces/msg/Duration\",\n];\n\nfunction parseBigIntLiteral(str: string, min: bigint, max: bigint) {\n  const value = BigInt(str);\n  if (value < min || value > max) {\n    throw new Error(`Number ${str} out of range [${min}, ${max}]`);\n  }\n  return value;\n}\n\nfunction parseNumberLiteral(str: string, min: number, max: number): number {\n  const value = parseInt(str);\n  if (Number.isNaN(value)) {\n    throw new Error(`Invalid numeric literal: ${str}`);\n  }\n  if (value < min || value > max) {\n    throw new Error(`Number ${str} out of range [${min}, ${max}]`);\n  }\n  return value;\n}\n\nconst LITERAL_REGEX = new RegExp(ARRAY_TERMINATED_LITERAL, \"y\");\nconst COMMA_OR_END_REGEX = /\\s*(,)\\s*|\\s*$/y;\nfunction parseArrayLiteral(\n  type: string,\n  rawStr: string,\n): boolean[] | bigint[] | number[] | string[] {\n  if (!rawStr.startsWith(\"[\") || !rawStr.endsWith(\"]\")) {\n    throw new Error(\"Array must start with [ and end with ]\");\n  }\n  const str = rawStr.substring(1, rawStr.length - 1);\n  if (type === \"string\" || type === \"wstring\") {\n    const results: string[] = [];\n    let offset = 0;\n    while (offset < str.length) {\n      if (str[offset] === \",\") {\n        throw new Error(\"Expected array element before comma\");\n      }\n      LITERAL_REGEX.lastIndex = offset;\n      let match = LITERAL_REGEX.exec(str);\n      if (match) {\n        results.push(parseStringLiteral(match[0]!));\n        offset = LITERAL_REGEX.lastIndex;\n      }\n\n      COMMA_OR_END_REGEX.lastIndex = offset;\n      match = COMMA_OR_END_REGEX.exec(str);\n      if (!match) {\n        throw new Error(\"Expected comma or end of array\");\n      }\n      if (!match[1]) {\n        break;\n      }\n      offset = COMMA_OR_END_REGEX.lastIndex;\n    }\n    return results;\n  }\n  return str.split(\",\").map((part) => parsePrimitiveLiteral(type, part.trim())) as\n    | boolean[]\n    | bigint[]\n    | number[]\n    | string[];\n}\n\nfunction parseStringLiteral(maybeQuotedStr: string): string {\n  let quoteThatMustBeEscaped = \"\";\n  let str = maybeQuotedStr;\n  for (const quote of [\"'\", '\"']) {\n    if (maybeQuotedStr.startsWith(quote)) {\n      if (!maybeQuotedStr.endsWith(quote)) {\n        throw new Error(`Expected terminating ${quote} in string literal: ${maybeQuotedStr}`);\n      }\n      quoteThatMustBeEscaped = quote;\n      str = maybeQuotedStr.substring(quote.length, maybeQuotedStr.length - quote.length);\n      break;\n    }\n  }\n  if (\n    !new RegExp(String.raw`^(?:[^\\\\${quoteThatMustBeEscaped}]|${STRING_ESCAPES})*$`).test(str) ==\n    undefined\n  ) {\n    throw new Error(`Invalid string literal: ${str}`);\n  }\n  return str.replace(new RegExp(STRING_ESCAPES, \"g\"), (...args) => {\n    const { char, oct, hex2, hex4, hex8 } = args[args.length - 1] as NonNullable<\n      RegExpMatchArray[\"groups\"]\n    >;\n    const hex = hex2 ?? hex4 ?? hex8;\n    if (char != undefined) {\n      return {\n        \"'\": \"'\",\n        '\"': '\"',\n        a: \"\\x07\",\n        b: \"\\b\",\n        f: \"\\f\",\n        n: \"\\n\",\n        r: \"\\r\",\n        t: \"\\t\",\n        v: \"\\v\",\n        \"\\\\\": \"\\\\\",\n      }[char]!;\n    } else if (oct != undefined) {\n      return String.fromCodePoint(parseInt(oct, 8));\n    } else if (hex != undefined) {\n      return String.fromCodePoint(parseInt(hex, 16));\n    } else {\n      throw new Error(\"Expected exactly one matched group\");\n    }\n  });\n}\n\nfunction parsePrimitiveLiteral(type: string, str: string): boolean | number | bigint | string {\n  switch (type) {\n    case \"bool\":\n      if ([\"true\", \"True\", \"1\"].includes(str)) {\n        return true;\n      } else if ([\"false\", \"False\", \"0\"].includes(str)) {\n        return false;\n      }\n      break;\n    case \"float32\":\n    case \"float64\": {\n      const value = parseFloat(str);\n      if (!Number.isNaN(value)) {\n        return value;\n      }\n      break;\n    }\n    case \"int8\":\n      return parseNumberLiteral(str, ~0x7f, 0x7f);\n    case \"uint8\":\n      return parseNumberLiteral(str, 0, 0xff);\n    case \"int16\":\n      return parseNumberLiteral(str, ~0x7fff, 0x7fff);\n    case \"uint16\":\n      return parseNumberLiteral(str, 0, 0xffff);\n    case \"int32\":\n      return parseNumberLiteral(str, ~0x7fffffff, 0x7fffffff);\n    case \"uint32\":\n      return parseNumberLiteral(str, 0, 0xffffffff);\n    case \"int64\":\n      return parseBigIntLiteral(str, ~0x7fffffffffffffffn, 0x7fffffffffffffffn);\n    case \"uint64\":\n      return parseBigIntLiteral(str, 0n, 0xffffffffffffffffn);\n    case \"string\":\n    case \"wstring\":\n      return parseStringLiteral(str);\n  }\n  throw new Error(`Invalid literal of type ${type}: ${str}`);\n}\n\nfunction normalizeType(type: string): string {\n  switch (type) {\n    case \"char\":\n      return \"uint8\";\n    case \"byte\":\n      return \"int8\";\n    case \"builtin_interfaces/Time\":\n    case \"builtin_interfaces/msg/Time\":\n      return \"time\";\n    case \"builtin_interfaces/Duration\":\n    case \"builtin_interfaces/msg/Duration\":\n      return \"duration\";\n  }\n  return type;\n}\nexport function buildRos2Type(lines: { line: string }[]): MessageDefinition {\n  const definitions: MessageDefinitionField[] = [];\n  let complexTypeName: string | undefined;\n  for (const { line } of lines) {\n    let match;\n    if (line.startsWith(\"#\")) {\n      continue;\n    } else if ((match = /^MSG: ([^ ]+)\\s*(?:#.+)?$/.exec(line))) {\n      complexTypeName = match[1];\n      continue;\n    } else if ((match = DEFINITION_LINE_REGEX.exec(line))) {\n      const {\n        type: rawType,\n        stringBound,\n        unboundedArray,\n        arrayLength,\n        arrayBound,\n        name,\n        constantValue,\n        defaultValue,\n      } = match.groups!;\n      const type = normalizeType(rawType!);\n\n      if (stringBound != undefined && type !== \"string\" && type !== \"wstring\") {\n        throw new Error(`Invalid string bound for type ${type}`);\n      }\n      if (constantValue != undefined) {\n        if (!/^[A-Z](?:_?[A-Z0-9]+)*$/.test(name!)) {\n          throw new Error(`Invalid constant name: ${name!}`);\n        }\n      } else {\n        if (!/^[a-z](?:_?[a-z0-9]+)*$/.test(name!)) {\n          throw new Error(`Invalid field name: ${name!}`);\n        }\n      }\n      const isComplex = !BUILTIN_TYPES.includes(type);\n      const isArray =\n        unboundedArray != undefined || arrayLength != undefined || arrayBound != undefined;\n      definitions.push({\n        name: name!,\n        type,\n        isComplex: constantValue != undefined ? isComplex || undefined : isComplex,\n        isConstant: constantValue != undefined || undefined,\n        isArray: constantValue != undefined ? isArray || undefined : isArray,\n        arrayLength: arrayLength != undefined ? parseInt(arrayLength) : undefined,\n        arrayUpperBound: arrayBound != undefined ? parseInt(arrayBound) : undefined,\n        upperBound: stringBound != undefined ? parseInt(stringBound) : undefined,\n        defaultValue:\n          defaultValue != undefined\n            ? isArray\n              ? parseArrayLiteral(type, defaultValue.trim())\n              : parsePrimitiveLiteral(type, defaultValue.trim())\n            : undefined,\n        value:\n          constantValue != undefined\n            ? parsePrimitiveLiteral(type, constantValue.trim())\n            : undefined,\n        valueText: constantValue?.trim(),\n      });\n    } else {\n      throw new Error(`Could not parse line: '${line}'`);\n    }\n  }\n  return { name: complexTypeName, definitions };\n}\n","/// <reference types=\"./extensions\" />\n\nexport * from \"./md5\";\nexport * from \"./parse\";\nexport * from \"./parseRos2idl\";\nexport * from \"./stringify\";\n","import { MessageDefinition } from \"@foxglove/message-definition\";\nimport { Md5 } from \"md5-typescript\";\n\nconst BUILTIN_TYPES = new Set([\n  \"int8\",\n  \"uint8\",\n  \"int16\",\n  \"uint16\",\n  \"int32\",\n  \"uint32\",\n  \"int64\",\n  \"uint64\",\n  \"float32\",\n  \"float64\",\n  \"string\",\n  \"bool\",\n  \"char\",\n  \"byte\",\n  \"time\",\n  \"duration\",\n]);\n\n/**\n * Converts a ROS 1 message definition (http://wiki.ros.org/msg) into an md5 checksum using the same\n * approach as `gendeps --md5` from ROS 1.\n * @param msgDefs The ROS message definition to generate a checksum for, and all dependent\n * sub-messages\n * @returns An md5 checksum string\n */\nexport function md5(msgDefs: MessageDefinition[]): string {\n  if (msgDefs.length === 0) {\n    throw new Error(`Cannot produce md5sum for empty msgDefs`);\n  }\n\n  const subMsgDefs = new Map<string, MessageDefinition>();\n  for (const msgDef of msgDefs) {\n    if (msgDef.name != undefined) {\n      subMsgDefs.set(msgDef.name, msgDef);\n    }\n  }\n\n  const first = msgDefs[0]!;\n  return computeMessageMd5(first, subMsgDefs);\n}\n\nfunction computeMessageMd5(\n  msgDef: MessageDefinition,\n  subMsgDefs: Map<string, MessageDefinition>,\n): string {\n  let output = \"\";\n  const constants = msgDef.definitions.filter(({ isConstant }) => isConstant);\n  const variables = msgDef.definitions.filter(\n    ({ isConstant }) => isConstant == undefined || !isConstant,\n  );\n\n  for (const def of constants) {\n    output += `${def.type} ${def.name}=${def.valueText ?? String(def.value)}\\n`;\n  }\n\n  for (const def of variables) {\n    if (isBuiltin(def.type)) {\n      const arrayLength = def.arrayLength != undefined ? String(def.arrayLength) : \"\";\n      const array = def.isArray === true ? `[${arrayLength}]` : \"\";\n      output += `${def.type}${array} ${def.name}\\n`;\n    } else {\n      const subMsgDef = subMsgDefs.get(def.type);\n      if (subMsgDef == undefined) {\n        throw new Error(`Missing definition for submessage type \"${def.type}\"`);\n      }\n      const subMd5 = computeMessageMd5(subMsgDef, subMsgDefs);\n      output += `${subMd5} ${def.name}\\n`;\n    }\n  }\n\n  output = output.trimEnd();\n  return Md5.init(output);\n}\n\nfunction isBuiltin(typeName: string): boolean {\n  return BUILTIN_TYPES.has(typeName);\n}\n","// This file incorporates work covered by the following copyright and\n// permission notice:\n//\n//   Copyright 2018-2021 Cruise LLC\n//\n//   This source code is licensed under the Apache License, Version 2.0,\n//   found at http://www.apache.org/licenses/LICENSE-2.0\n//   You may not use this file except in compliance with the License.\n\nimport { MessageDefinition, MessageDefinitionField } from \"@foxglove/message-definition\";\nimport { Grammar, Parser } from \"nearley\";\n\nimport { buildRos2Type } from \"./buildRos2Type\";\nimport ros1Rules from \"./ros1.ne\";\nimport ros2idlRules from \"./ros2idl.ne\";\n\nconst ROS1_GRAMMAR = Grammar.fromCompiled(ros1Rules);\nexport const ROS2IDL_GRAMMAR = Grammar.fromCompiled(ros2idlRules);\n\nexport type ParseOptions = {\n  /** Parse message definitions as ROS 2. Otherwise, parse as ROS1 */\n  ros2?: boolean;\n  /**\n   * Return the original type names used in the file, without normalizing to\n   * fully qualified type names\n   */\n  skipTypeFixup?: boolean;\n};\n\n// Given a raw message definition string, parse it into an object representation.\n// Example return value:\n// [{\n//   name: undefined,\n//   definitions: [\n//     {\n//       arrayLength: undefined,\n//       isArray: false,\n//       isComplex: false,\n//       name: \"name\",\n//       type: \"string\",\n//       defaultValue: undefined\n//     }, ...\n//   ],\n// }, ... ]\n//\n// See unit tests for more examples.\nexport function parse(messageDefinition: string, options: ParseOptions = {}): MessageDefinition[] {\n  // read all the lines and remove empties\n  const allLines = messageDefinition\n    .split(\"\\n\")\n    .map((line) => line.trim())\n    .filter((line) => line);\n\n  let definitionLines: { line: string }[] = [];\n  const types: MessageDefinition[] = [];\n  // group lines into individual definitions\n  allLines.forEach((line) => {\n    // ignore comment lines\n    if (line.startsWith(\"#\")) {\n      return;\n    }\n\n    // definitions are split by equal signs\n    if (line.startsWith(\"==\")) {\n      types.push(\n        options.ros2 === true\n          ? buildRos2Type(definitionLines)\n          : buildType(definitionLines, ROS1_GRAMMAR),\n      );\n      definitionLines = [];\n    } else {\n      definitionLines.push({ line });\n    }\n  });\n  types.push(\n    options.ros2 === true\n      ? buildRos2Type(definitionLines)\n      : buildType(definitionLines, ROS1_GRAMMAR),\n  );\n\n  // Fix up complex type names\n  if (options.skipTypeFixup !== true) {\n    fixupTypes(types);\n  }\n\n  return types;\n}\n\nexport function fixupTypes(types: MessageDefinition[]): void {\n  types.forEach(({ definitions }) => {\n    definitions.forEach((definition) => {\n      if (definition.isComplex === true) {\n        const foundName = findTypeByName(types, definition.type).name;\n        if (foundName == undefined) {\n          throw new Error(`Missing type definition for ${definition.type}`);\n        }\n        definition.type = foundName;\n      }\n    });\n  });\n}\n\nfunction buildType(lines: { line: string }[], grammar: Grammar): MessageDefinition {\n  const definitions: MessageDefinitionField[] = [];\n  let complexTypeName: string | undefined;\n  lines.forEach(({ line }) => {\n    if (line.startsWith(\"MSG:\")) {\n      const [_, name] = simpleTokenization(line);\n      complexTypeName = name?.trim();\n      return;\n    }\n\n    const parser = new Parser(grammar);\n    parser.feed(line);\n    const results = parser.finish() as MessageDefinitionField[];\n    if (results.length === 0) {\n      throw new Error(`Could not parse line: '${line}'`);\n    } else if (results.length > 1) {\n      throw new Error(`Ambiguous line: '${line}'`);\n    }\n    const result = results[0];\n    if (result != undefined) {\n      result.type = normalizeType(result.type);\n      definitions.push(result);\n    }\n  });\n  return { name: complexTypeName, definitions };\n}\n\nfunction simpleTokenization(line: string): string[] {\n  return line\n    .replace(/#.*/gi, \"\")\n    .split(\" \")\n    .filter((word) => word);\n}\n\nfunction findTypeByName(types: MessageDefinition[], name: string): MessageDefinition {\n  const matches = types.filter((type) => {\n    const typeName = type.name ?? \"\";\n    // if the search is empty, return unnamed types\n    if (name.length === 0) {\n      return typeName.length === 0;\n    }\n    // return if the search is in the type name\n    // or matches exactly if a fully-qualified name match is passed to us\n    const nameEnd = name.includes(\"/\") ? name : `/${name}`;\n    return typeName.endsWith(nameEnd);\n  });\n  if (matches[0] == undefined) {\n    throw new Error(\n      `Expected 1 top level type definition for '${name}' but found ${matches.length}`,\n    );\n  }\n  return matches[0];\n}\n\nexport function normalizeType(type: string): string {\n  // Normalize deprecated aliases\n  if (type === \"char\") {\n    return \"uint8\";\n  } else if (type === \"byte\") {\n    return \"int8\";\n  }\n  return type;\n}\n","import {\n  ConstantValue,\n  MessageDefinition,\n  MessageDefinitionField,\n} from \"@foxglove/message-definition\";\nimport { Grammar, Parser } from \"nearley\";\n\nimport { ROS2IDL_GRAMMAR, normalizeType } from \"./parse\";\n\n/**\n *\n * @param messageDefinition - ros2idl decoded message definition string\n * @returns - parsed message definition\n */\n\nexport function parseRos2idl(messageDefinition: string): MessageDefinition[] {\n  return buildRos2idlType(messageDefinition, ROS2IDL_GRAMMAR);\n}\ntype RawIdlDefinition = {\n  definitions: (RawIdlDefinition | RawIdlFieldDefinition)[];\n  name: string;\n  definitionType: \"module\" | \"struct\";\n};\ntype RawIdlFieldDefinition = Partial<MessageDefinitionField> & {\n  definitions: undefined;\n  definitionType: \"typedef\";\n  constantUsage?: [keyof MessageDefinitionField, string][];\n};\nfunction buildRos2idlType(messageDefinition: string, grammar: Grammar): MessageDefinition[] {\n  const parser = new Parser(grammar);\n  parser.feed(messageDefinition);\n  const results = parser.finish();\n\n  if (results.length === 0) {\n    throw new Error(\n      `Could not parse message definition (unexpected end of input): '${messageDefinition}'`,\n    );\n  }\n  const result = results[0] as RawIdlDefinition[];\n  const processedResult = postProcessIdlDefinitions(result);\n  for (const { definitions } of processedResult) {\n    for (const definition of definitions) {\n      definition.type = normalizeType(definition.type);\n    }\n  }\n\n  return processedResult;\n}\nfunction traverseIdl(\n  path: (RawIdlDefinition | RawIdlFieldDefinition)[],\n  processNode: (path: (RawIdlDefinition | RawIdlFieldDefinition)[]) => void,\n) {\n  const currNode = path[path.length - 1]!;\n  const children: (RawIdlDefinition | RawIdlFieldDefinition)[] | undefined = currNode.definitions;\n  if (children) {\n    children.forEach((n) => traverseIdl([...path, n], processNode));\n  }\n  processNode(path);\n}\nfunction postProcessIdlDefinitions(definitions: RawIdlDefinition[]): MessageDefinition[] {\n  const finalDefs: MessageDefinition[] = [];\n  // Need to update the names of modules and structs to be in their respective namespaces\n  for (const definition of definitions) {\n    const typedefMap = new Map<string, Partial<RawIdlFieldDefinition>>();\n    const constantValueMap = new Map<string, ConstantValue>();\n    // build constant and typedef maps\n    traverseIdl([definition], (path) => {\n      const node = path[path.length - 1] as RawIdlFieldDefinition;\n      if (node.definitionType === \"typedef\") {\n        // typedefs must have a name\n        const { definitionType: _definitionType, name: _name, ...partialDef } = node;\n        typedefMap.set(node.name!, partialDef);\n      } else if (node.isConstant === true) {\n        constantValueMap.set(node.name!, node.value);\n      }\n    });\n\n    // modify ast field nodes in-place to replace typedefs and constants\n    // also fix up names to use ros package resource names\n    traverseIdl([definition], (path) => {\n      const node = path[path.length - 1]!;\n      if (node.definitions != undefined) {\n        return;\n      }\n      // replace field definition with corresponding typedef aliased definition\n      if (node.type && typedefMap.has(node.type)) {\n        Object.assign(node, { ...typedefMap.get(node.type), name: node.name });\n      }\n\n      // need to iterate through keys because this can occur on arrayLength, upperBound, arrayUpperBound, value, defaultValue\n      for (const [key, constantName] of node.constantUsage ?? []) {\n        if (constantValueMap.has(constantName)) {\n          (node[key] as ConstantValue) = constantValueMap.get(constantName);\n        } else {\n          throw new Error(\n            `Could not find constant <${constantName}> for field <${\n              node.name ?? \"undefined\"\n            }> in <${definition.name}>`,\n          );\n        }\n      }\n      delete node.constantUsage;\n\n      if (node.type != undefined) {\n        node.type = node.type.replace(/::/g, \"/\");\n      }\n    });\n\n    const flattened = flattenIdlNamespaces(definition);\n    finalDefs.push(...flattened);\n  }\n\n  return finalDefs;\n}\nfunction flattenIdlNamespaces(definition: RawIdlDefinition): MessageDefinition[] {\n  const flattened: MessageDefinition[] = [];\n\n  traverseIdl([definition], (path) => {\n    const node = path[path.length - 1] as RawIdlDefinition;\n    if (node.definitionType === \"module\") {\n      const moduleDefs = node.definitions.filter((d) => d.definitionType !== \"typedef\");\n      // only add modules if all fields are constants (complex leaf)\n      if (moduleDefs.every((child) => (child as RawIdlFieldDefinition).isConstant)) {\n        flattened.push({\n          name: path.map((n) => n.name).join(\"/\"),\n          definitions: moduleDefs as MessageDefinitionField[],\n        });\n      }\n    } else if (node.definitionType === \"struct\") {\n      // all structs are leaf nodes to be added\n      flattened.push({\n        name: path.map((n) => n.name).join(\"/\"),\n        definitions: node.definitions as MessageDefinitionField[],\n      });\n    }\n  });\n\n  return flattened;\n}\n","import { MessageDefinition, DefaultValue } from \"@foxglove/message-definition\";\n\n// Converts a ROS message definition (http://wiki.ros.org/msg) into a canonical\n// message description format that is suitable for MD5 checksum generation\nexport function stringify(msgDefs: MessageDefinition[]): string {\n  let output = \"\";\n  for (let i = 0; i < msgDefs.length; i++) {\n    const msgDef = msgDefs[i] as MessageDefinition;\n    const constants = msgDef.definitions.filter(({ isConstant }) => isConstant);\n    const variables = msgDef.definitions.filter(\n      ({ isConstant }) => isConstant == undefined || !isConstant,\n    );\n\n    if (i > 0) {\n      output +=\n        \"\\n================================================================================\\n\";\n      output += `MSG: ${msgDef.name ?? \"\"}\\n`;\n    }\n\n    for (const def of constants) {\n      output += `${def.type} ${def.name} = ${def.valueText ?? String(def.value)}\\n`;\n    }\n    if (variables.length > 0) {\n      if (output.length > 0) {\n        output += \"\\n\";\n      }\n      for (const def of variables) {\n        const upperBound = def.upperBound != undefined ? `<=${def.upperBound}` : \"\";\n        const arrayLength =\n          def.arrayLength != undefined\n            ? String(def.arrayLength)\n            : def.arrayUpperBound != undefined\n            ? `<=${def.arrayUpperBound}`\n            : \"\";\n        const array = def.isArray === true ? `[${arrayLength}]` : \"\";\n        const defaultValue =\n          def.defaultValue != undefined ? ` ${stringifyDefaultValue(def.defaultValue)}` : \"\";\n        output += `${def.type}${upperBound}${array} ${def.name}${defaultValue}\\n`;\n      }\n    }\n  }\n\n  return output.trimEnd();\n}\n\nfunction stringifyDefaultValue(value: DefaultValue): string {\n  if (Array.isArray(value)) {\n    return `[${value\n      .map((x) => (typeof x === \"bigint\" ? x.toString() : JSON.stringify(x)))\n      .join(\", \")}]`;\n  }\n  return typeof value === \"bigint\" ? value.toString() : JSON.stringify(value);\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(715);\n",""],"names":[],"sourceRoot":""}