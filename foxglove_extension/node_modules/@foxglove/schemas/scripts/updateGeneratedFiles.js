"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const commander_1 = require("commander");
const promises_1 = tslib_1.__importDefault(require("fs/promises"));
const path_1 = tslib_1.__importDefault(require("path"));
const rimraf_1 = tslib_1.__importDefault(require("rimraf"));
const internal_1 = require("../internal");
const exportTypeScriptSchemas_1 = require("../internal/exportTypeScriptSchemas");
const generateFlatbufferSchema_1 = require("../internal/generateFlatbufferSchema");
const generateJsonSchema_1 = require("../internal/generateJsonSchema");
const generateMarkdown_1 = require("../internal/generateMarkdown");
const generateOmgIdl_1 = require("../internal/generateOmgIdl");
const generateProto_1 = require("../internal/generateProto");
const schemas_1 = require("../internal/schemas");
async function logProgress(message, body) {
    process.stderr.write(`${message}... `);
    await body();
    process.stderr.write("done\n");
}
async function main({ outDir, rosOutDir }) {
    await logProgress("Removing any existing output directory", async () => {
        await (0, rimraf_1.default)(outDir);
    });
    await logProgress("Generating JSONSchema definitions", async () => {
        await promises_1.default.mkdir(path_1.default.join(outDir, "jsonschema"), { recursive: true });
        let indexTS = "// Generated by https://github.com/foxglove/schemas\n\n";
        for (const schema of Object.values(schemas_1.foxgloveMessageSchemas)) {
            const json = JSON.stringify((0, generateJsonSchema_1.generateJsonSchema)(schema), undefined, 2);
            await promises_1.default.writeFile(path_1.default.join(outDir, "jsonschema", `${schema.name}.json`), json + "\n");
            indexTS += `export const ${schema.name} = ${json};\n\n`;
        }
        await promises_1.default.writeFile(path_1.default.join(outDir, "jsonschema", `index.ts`), indexTS);
    });
    await logProgress("Generating ROS 1 msg files", async () => {
        await promises_1.default.mkdir(path_1.default.join(outDir, "ros1"), { recursive: true });
        await promises_1.default.mkdir(path_1.default.join(rosOutDir, "ros1"), { recursive: true });
        for (const schema of Object.values(schemas_1.foxgloveMessageSchemas)) {
            if (schema.rosEquivalent != undefined) {
                continue;
            }
            const msg = (0, internal_1.generateRosMsg)((0, internal_1.generateRosMsgDefinition)(schema, { rosVersion: 1 }), {
                rosVersion: 1,
            });
            await promises_1.default.writeFile(path_1.default.join(outDir, "ros1", `${schema.name}.msg`), msg);
            await promises_1.default.writeFile(path_1.default.join(rosOutDir, "ros1", `${schema.name}.msg`), msg);
        }
    });
    await logProgress("Generating ROS 2 msg files", async () => {
        await promises_1.default.mkdir(path_1.default.join(outDir, "ros2"), { recursive: true });
        await promises_1.default.mkdir(path_1.default.join(rosOutDir, "ros2"), { recursive: true });
        for (const schema of Object.values(schemas_1.foxgloveMessageSchemas)) {
            if (schema.rosEquivalent != undefined) {
                continue;
            }
            const msg = (0, internal_1.generateRosMsg)((0, internal_1.generateRosMsgDefinition)(schema, { rosVersion: 2 }), {
                rosVersion: 2,
            });
            await promises_1.default.writeFile(path_1.default.join(outDir, "ros2", `${schema.name}.msg`), msg);
            await promises_1.default.writeFile(path_1.default.join(rosOutDir, "ros2", `${schema.name}.msg`), msg);
        }
    });
    await logProgress("Generating Protobuf definitions", async () => {
        await promises_1.default.mkdir(path_1.default.join(outDir, "proto", "foxglove"), { recursive: true });
        for (const schema of Object.values(schemas_1.foxgloveMessageSchemas)) {
            const enums = Object.values(schemas_1.foxgloveEnumSchemas).filter((enumSchema) => enumSchema.parentSchemaName === schema.name);
            await promises_1.default.writeFile(path_1.default.join(outDir, "proto", "foxglove", `${schema.name}.proto`), (0, generateProto_1.generateProto)(schema, enums));
        }
    });
    await logProgress("Generating FlatBuffer definitions", async () => {
        await promises_1.default.mkdir(path_1.default.join(outDir, "flatbuffer"), { recursive: true });
        await promises_1.default.writeFile(path_1.default.join(outDir, "flatbuffer", "ByteVector.fbs"), generateFlatbufferSchema_1.BYTE_VECTOR_FB);
        await promises_1.default.writeFile(path_1.default.join(outDir, "flatbuffer", "Time.fbs"), generateFlatbufferSchema_1.TIME_FB);
        await promises_1.default.writeFile(path_1.default.join(outDir, "flatbuffer", "Duration.fbs"), generateFlatbufferSchema_1.DURATION_FB);
        for (const schema of Object.values(schemas_1.foxgloveMessageSchemas)) {
            // want enums with their corresponding parent tables for usage
            const enums = Object.values(schemas_1.foxgloveEnumSchemas).filter((enumSchema) => enumSchema.parentSchemaName === schema.name);
            await promises_1.default.writeFile(path_1.default.join(outDir, "flatbuffer", `${schema.name}.fbs`), (0, generateFlatbufferSchema_1.generateFlatbuffers)(schema, enums));
        }
    });
    await logProgress("Generating TypeScript definitions", async () => {
        await promises_1.default.mkdir(path_1.default.join(outDir, "typescript"), { recursive: true });
        const schemas = (0, exportTypeScriptSchemas_1.exportTypeScriptSchemas)();
        for (const [name, source] of schemas.entries()) {
            await promises_1.default.writeFile(path_1.default.join(outDir, "typescript", `${name}.ts`), source);
        }
    });
    await logProgress("Generating OMG IDL definitions", async () => {
        await promises_1.default.mkdir(path_1.default.join(outDir, "omgidl", "foxglove"), { recursive: true });
        await promises_1.default.writeFile(path_1.default.join(outDir, "omgidl", "foxglove", "Time.idl"), generateOmgIdl_1.TIME_IDL);
        await promises_1.default.writeFile(path_1.default.join(outDir, "omgidl", "foxglove", "Duration.idl"), generateOmgIdl_1.DURATION_IDL);
        for (const schema of Object.values(schemas_1.foxgloveMessageSchemas)) {
            await promises_1.default.writeFile(path_1.default.join(outDir, "omgidl", "foxglove", `${schema.name}.idl`), (0, generateOmgIdl_1.generateOmgIdl)(schema));
        }
        for (const schema of Object.values(schemas_1.foxgloveEnumSchemas)) {
            await promises_1.default.writeFile(path_1.default.join(outDir, "omgidl", "foxglove", `${schema.name}.idl`), (0, generateOmgIdl_1.generateOmgIdl)(schema));
        }
    });
    await logProgress("Generating README.md", async () => {
        await promises_1.default.writeFile(path_1.default.join(outDir, "README.md"), (0, generateMarkdown_1.generateMarkdown)(Object.values(schemas_1.foxgloveMessageSchemas), Object.values(schemas_1.foxgloveEnumSchemas)));
    });
}
commander_1.program
    .requiredOption("-o, --out-dir <dir>", "output directory")
    .requiredOption("--ros-out-dir <dir>", "output directory for additional copies of ROS msgs")
    .action(main);
commander_1.program.parseAsync().catch(console.error);
//# sourceMappingURL=updateGeneratedFiles.js.map